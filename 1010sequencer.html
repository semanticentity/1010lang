<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>$1010 SEQUENCER</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel="stylesheet">
  <link href="https://fonts.cdnfonts.com/css/venice-classic-2" rel="stylesheet">
  <style>
    :root {
      --gb-0: #9bbc0f;
      --gb-1: #8bac0f;
      --gb-2: #306230;
      --gb-3: #0f380f;
      --c-term: #0a0a0f;
      --c-text: #ccc;
      --c-acc: #ff0055;
      --c-cyan: #00ffff;
      --c-magenta: #ff00ff;
      --c-yellow: #ffff00;
      --font-head: 'Venice Classic', sans-serif;
      --font: 'IBM Plex Mono', monospace;
    }

    body {
      background: var(--c-term);
      background-image:
        radial-gradient(ellipse at top, rgba(48, 98, 48, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse at bottom, rgba(255, 0, 85, 0.1) 0%, transparent 50%);
      color: var(--c-text);
      font-family: var(--font), monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      margin: 0;
      min-height: 100vh;
    }

    h1 {
      font-family: var(--font-head);
      font-size: 2.8rem;
      color: var(--gb-0);
      text-transform: uppercase;
      letter-spacing: 2px;
      margin: 0 0 10px;
      text-align: center;
      text-shadow:
        0 0 10px var(--gb-0),
        0 0 20px var(--gb-2),
        0 0 40px var(--gb-2);
      animation: titlePulse 4s ease-in-out infinite;
    }

    @keyframes titlePulse {
      0%, 100% { text-shadow: 0 0 10px var(--gb-0), 0 0 20px var(--gb-2), 0 0 40px var(--gb-2); }
      50% { text-shadow: 0 0 20px var(--gb-0), 0 0 40px var(--gb-1), 0 0 60px var(--gb-2); }
    }

    .synth-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 15px;
      max-width: 520px;
      width: 100%;
    }

    .screen-bezel {
      background: linear-gradient(145deg, #3a3a3a 0%, #252525 50%, #1a1a1a 100%);
      padding: 20px 20px 25px;
      border-radius: 12px 12px 45px 12px;
      box-shadow:
        inset -5px -5px 15px rgba(0, 0, 0, 0.6),
        inset 2px 2px 5px rgba(255, 255, 255, 0.05),
        0 10px 40px rgba(0, 0, 0, 0.8),
        0 0 80px rgba(155, 188, 15, 0.1);
      display: flex;
      justify-content: center;
      position: relative;
      border: 1px solid #555;
    }

    canvas#lcd {
      background: var(--gb-0);
      width: 320px;
      height: 288px;
      border: 4px solid #222;
      image-rendering: pixelated;
      box-shadow:
        inset 0 0 30px rgba(0, 0, 0, 0.3),
        0 0 20px rgba(155, 188, 15, 0.3);
    }

    /* CRT scanline effect overlay */
    .screen-bezel::after {
      content: '';
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      bottom: 25px;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.1) 2px,
        rgba(0, 0, 0, 0.1) 4px
      );
      pointer-events: none;
      border-radius: 4px;
    }

    .power-led {
      position: absolute;
      top: 50%;
      left: 10px;
      width: 10px;
      height: 10px;
      background: #222;
      border-radius: 50%;
      transform: translateY(-50%);
      border: 1px solid #333;
    }

    .power-led.on {
      background: radial-gradient(circle, #ff3333 0%, #cc0000 100%);
      box-shadow: 0 0 10px #f00, 0 0 20px #f00, 0 0 30px rgba(255, 0, 0, 0.5);
      animation: ledPulse 2s ease-in-out infinite;
    }

    @keyframes ledPulse {
      0%, 100% { box-shadow: 0 0 10px #f00, 0 0 20px #f00; }
      50% { box-shadow: 0 0 15px #f00, 0 0 30px #f00, 0 0 40px rgba(255, 0, 0, 0.3); }
    }

    .code-block {
      background: linear-gradient(180deg, #0a0a0a 0%, #000 100%);
      border: 1px solid var(--gb-2);
      padding: 12px;
      border-radius: 6px;
      box-shadow:
        inset 0 2px 10px rgba(0, 0, 0, 0.8),
        0 0 20px rgba(155, 188, 15, 0.1);
    }

    .label-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--gb-0);
      margin-bottom: 5px;
    }

    textarea {
      width: 100%;
      height: 280px;
      background: #111;
      color: #fff;
      border: none;
      font-family: var(--font), monospace;
      font-size: 12px;
      line-height: 1.5;
      resize: vertical;
      outline: none;
      padding: 8px;
      box-sizing: border-box;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
      width: 100%;
      max-width: 480px;
      margin: 0 auto;
    }

    /* PRIMARY TRANSPORT - Row 1: Play + Tempo */
    .transport-row {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .play-btn {
      min-width: 60px;
      height: 32px;
      border-radius: 4px;
      font-size: 0.8rem;
      padding: 0 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      background: linear-gradient(180deg, var(--gb-0) 0%, var(--gb-1) 100%);
      color: var(--gb-3);
      font-weight: bold;
      box-shadow: 0 0 15px rgba(155, 188, 15, 0.4);
    }

    .play-btn.playing {
      background: linear-gradient(180deg, var(--c-acc) 0%, #aa0044 100%);
      color: #fff;
      box-shadow: 0 0 20px rgba(255, 0, 85, 0.6);
    }

    .tempo-cluster {
      display: flex;
      align-items: center;
      background: rgba(0,0,0,0.4);
      border-radius: 4px;
      padding: 3px;
      gap: 2px;
    }

    .tempo-btn {
      width: 32px;
      height: 28px;
      padding: 0;
      font-size: 1.1rem;
      border-radius: 3px;
    }

    .tempo-val {
      color: var(--gb-0);
      font-size: 1rem;
      font-weight: bold;
      padding: 0 10px;
      min-width: 40px;
      text-align: center;
    }

    .scene-cluster {
      display: flex;
      gap: 4px;
    }

    .scene-btn {
      width: 32px;
      height: 28px;
      padding: 0;
      font-size: 0.8rem;
      border-radius: 3px;
    }

    .scene-btn.copy-target {
      animation: blink 0.3s infinite;
    }

    @keyframes blink {
      50% { background: var(--c-acc); }
    }

    .bar-counter {
      font-size: 0.7rem;
      color: var(--gb-0);
      background: #111;
      padding: 6px 10px;
      border-radius: 4px;
      font-family: var(--font);
      min-width: 60px;
      text-align: center;
      border: 1px solid #333;
    }

    .rec-btn {
      width: 40px;
      height: 28px;
      padding: 0;
      font-size: 0.6rem;
      border-radius: 3px;
      background: linear-gradient(180deg, #333 0%, #222 100%);
      color: #666;
      border: 1px solid #444;
    }

    .rec-btn.active {
      background: linear-gradient(180deg, #cc0000 0%, #990000 100%);
      color: #fff;
      border-color: #ff3333;
      box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
      animation: recPulse 1s ease-in-out infinite;
    }

    @keyframes recPulse {
      0%, 100% { box-shadow: 0 0 8px rgba(255, 0, 0, 0.5); }
      50% { box-shadow: 0 0 16px rgba(255, 0, 0, 0.8); }
    }

    .tools-toggle {
      width: 32px;
      height: 28px;
      padding: 0;
      font-size: 1rem;
      border-radius: 3px;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .tools-toggle:hover, .tools-toggle.active {
      opacity: 1;
    }

    /* CONTEXT BAR - Subtle info display */
    .context-bar {
      display: flex;
      justify-content: center;
      gap: 8px;
      align-items: center;
      padding: 4px 0;
    }

    .context-tag {
      font-size: 0.6rem;
      color: var(--gb-2);
      background: rgba(48, 98, 48, 0.2);
      padding: 2px 6px;
      border-radius: 3px;
      letter-spacing: 1px;
    }

    /* TOOLS DRAWER - Progressive disclosure */
    .tools-drawer {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out, padding 0.3s ease-out;
      padding: 0;
    }

    .tools-drawer.open {
      max-height: 150px;
      padding: 8px 0;
    }

    .tool-groups {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }

    .tool-group {
      display: flex;
      align-items: center;
      gap: 2px;
      background: rgba(0,0,0,0.3);
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #222;
    }

    .group-label {
      font-size: 0.45rem;
      color: #555;
      margin-right: 4px;
      letter-spacing: 1px;
      min-width: 28px;
    }

    .tool-btn {
      width: 32px;
      height: 26px;
      padding: 0 4px;
      font-size: 0.55rem;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      letter-spacing: 0;
    }

    .pack-select {
      height: 26px;
      padding: 0 4px;
      font-size: 0.55rem;
      font-family: var(--font);
      background: var(--c-term);
      color: var(--gb-0);
      border: 1px solid var(--gb-2);
      border-radius: 3px;
      cursor: pointer;
      min-width: 60px;
    }
    .pack-select:hover {
      border-color: var(--gb-0);
    }
    .pack-select:focus {
      outline: none;
      border-color: var(--c-cyan);
    }
    .pack-select option {
      background: var(--c-term);
      color: var(--c-text);
    }
    .pack-select optgroup {
      color: var(--gb-0);
      font-weight: bold;
    }

    .pack-mode {
      height: 26px;
      padding: 0 2px;
      font-size: 0.5rem;
      font-family: var(--font);
      background: var(--c-term);
      color: var(--c-cyan);
      border: 1px solid var(--gb-2);
      border-radius: 3px;
      cursor: pointer;
      min-width: 36px;
    }
    .pack-mode:hover { border-color: var(--c-cyan); }

    /* Pack Browser Panel */
    .pack-browser {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      background: var(--c-term);
      border: 2px solid var(--gb-0);
      border-radius: 8px;
      z-index: 1000;
      box-shadow: 0 0 30px rgba(0,0,0,0.8);
      overflow: hidden;
    }
    .pack-browser.open { display: block; }
    .pack-browser-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: var(--gb-2);
      border-bottom: 1px solid var(--gb-1);
    }
    .pack-browser-title {
      font-size: 0.7rem;
      color: var(--gb-0);
      font-weight: bold;
    }
    .pack-browser-close {
      background: none;
      border: none;
      color: var(--c-acc);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0 4px;
    }
    .pack-stack {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      padding: 8px;
      min-height: 36px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid var(--gb-2);
    }
    .pack-stack-label {
      font-size: 0.5rem;
      color: var(--gb-1);
      width: 100%;
      margin-bottom: 2px;
    }
    .pack-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      font-size: 0.55rem;
      background: var(--gb-2);
      border: 1px solid var(--gb-0);
      border-radius: 12px;
      color: var(--gb-0);
    }
    .pack-chip.drums { border-color: var(--c-acc); color: var(--c-acc); }
    .pack-chip.synth { border-color: var(--c-cyan); color: var(--c-cyan); }
    .pack-chip.sampler { border-color: #f0a; color: #f0a; }
    .pack-chip.genre { border-color: var(--c-ylw); color: var(--c-ylw); }
    .pack-chip-remove {
      cursor: pointer;
      opacity: 0.6;
      font-size: 0.7rem;
    }
    .pack-chip-remove:hover { opacity: 1; }
    .pack-mode-label {
      display: inline-flex;
      align-items: center;
      padding: 2px 6px;
      font-size: 0.45rem;
      font-weight: bold;
      color: var(--c-cyan);
      opacity: 0.8;
    }
    .pack-facets {
      display: flex;
      gap: 4px;
      padding: 8px;
      border-bottom: 1px solid var(--gb-2);
      flex-wrap: wrap;
    }
    .pack-facet {
      padding: 4px 10px;
      font-size: 0.55rem;
      background: transparent;
      border: 1px solid var(--gb-1);
      border-radius: 3px;
      color: var(--gb-1);
      cursor: pointer;
      transition: all 0.15s;
    }
    .pack-facet:hover { border-color: var(--gb-0); color: var(--gb-0); }
    .pack-facet.active {
      background: var(--gb-0);
      color: var(--c-term);
      border-color: var(--gb-0);
    }
    .pack-facet.drums.active { background: var(--c-acc); border-color: var(--c-acc); }
    .pack-facet.synth.active { background: var(--c-cyan); border-color: var(--c-cyan); }
    .pack-facet.sampler.active { background: #f0a; border-color: #f0a; }
    .pack-facet.genre.active { background: var(--c-ylw); border-color: var(--c-ylw); color: #000; }
    .pack-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      gap: 6px;
      padding: 10px;
      max-height: 300px;
      overflow-y: auto;
    }
    .pack-item {
      padding: 8px 6px;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--gb-2);
      border-radius: 4px;
      cursor: pointer;
      text-align: center;
      transition: all 0.15s;
    }
    .pack-item:hover {
      border-color: var(--gb-0);
      background: rgba(155,188,15,0.1);
    }
    .pack-item.loaded {
      border-color: var(--gb-0);
      background: rgba(155,188,15,0.2);
    }
    .pack-item-name {
      font-size: 0.6rem;
      color: var(--gb-0);
      font-weight: bold;
    }
    .pack-item-year {
      font-size: 0.45rem;
      color: var(--gb-1);
      margin-top: 2px;
    }
    .pack-item.drums .pack-item-name { color: var(--c-acc); }
    .pack-item.synth .pack-item-name { color: var(--c-cyan); }
    .pack-item.sampler .pack-item-name { color: #f0a; }
    .pack-item.genre .pack-item-name { color: var(--c-ylw); }
    .pack-mode-bar {
      display: flex;
      gap: 4px;
      padding: 8px;
      background: rgba(0,0,0,0.2);
      border-top: 1px solid var(--gb-2);
      align-items: center;
    }
    .pack-mode-bar label {
      font-size: 0.5rem;
      color: var(--gb-1);
      margin-right: 4px;
    }
    .pack-mode-btn {
      padding: 4px 8px;
      font-size: 0.5rem;
      background: transparent;
      border: 1px solid var(--gb-2);
      color: var(--gb-1);
      cursor: pointer;
      border-radius: 3px;
    }
    .pack-mode-btn:hover { border-color: var(--gb-0); }
    .pack-mode-btn.active {
      background: var(--gb-0);
      color: var(--c-term);
      border-color: var(--gb-0);
    }
    .pack-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 999;
    }
    .pack-overlay.open { display: block; }
    .pack-btn-open {
      padding: 2px 8px;
      font-size: 0.55rem;
      background: linear-gradient(180deg, var(--gb-2) 0%, #1a3a1a 100%);
      border: 1px solid var(--gb-0);
      color: var(--gb-0);
      cursor: pointer;
      border-radius: 3px;
    }
    .pack-btn-open:hover { background: var(--gb-0); color: var(--c-term); }

    .tool-btn:hover {
      transform: scale(1.1);
    }

    .tool-btn.active {
      background: linear-gradient(180deg, var(--c-acc) 0%, #aa0044 100%);
      border-color: #ff3366;
    }

    button {
      background: linear-gradient(180deg, var(--gb-2) 0%, #1a3a1a 100%);
      color: var(--gb-0);
      border: 2px solid var(--gb-0);
      padding: 8px 16px;
      font-family: inherit;
      font-size: 0.8rem;
      font-weight: bold;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.15s ease;
      text-shadow: 0 0 5px var(--gb-0);
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(155, 188, 15, 0.2), transparent);
      transition: left 0.4s ease;
    }

    button:hover {
      background: linear-gradient(180deg, var(--gb-1) 0%, var(--gb-2) 100%);
      color: var(--gb-3);
      box-shadow: 0 0 15px rgba(155, 188, 15, 0.4), inset 0 0 10px rgba(155, 188, 15, 0.2);
      text-shadow: none;
    }

    button:hover::before {
      left: 100%;
    }

    button:active {
      transform: translateY(2px);
      box-shadow: 0 0 5px rgba(155, 188, 15, 0.3);
    }

    button.primary {
      background: linear-gradient(180deg, var(--gb-0) 0%, var(--gb-1) 100%);
      color: var(--gb-3);
      box-shadow: 0 0 20px rgba(155, 188, 15, 0.5), 0 0 40px rgba(155, 188, 15, 0.2);
      text-shadow: none;
    }

    /* Evolve button special glow when active */
    button.evolve-active {
      background: linear-gradient(180deg, var(--c-acc) 0%, #aa0033 100%);
      border-color: var(--c-acc);
      color: #fff;
      animation: evolveGlow 1s ease-in-out infinite;
    }

    @keyframes evolveGlow {
      0%, 100% { box-shadow: 0 0 10px var(--c-acc), 0 0 20px var(--c-acc); }
      50% { box-shadow: 0 0 20px var(--c-acc), 0 0 40px var(--c-acc), 0 0 60px rgba(255, 0, 85, 0.3); }
    }

    .mem-row {
      display: grid;
      grid-template-columns: 60px repeat(16, 1fr);
      gap: 2px;
      margin-top: 4px;
      font-size: 8px;
    }

    .mem-label {
      color: var(--gb-0);
      text-align: right;
      padding-right: 4px;
    }

    .mem-cell {
      aspect-ratio: 1;
      background: #222;
      border: 1px solid #333;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #444;
      font-size: 7px;
      cursor: pointer;
    }

    /* Memory debugger header */
    .mem-header {
      display: grid;
      grid-template-columns: 50px repeat(16, 1fr);
      gap: 1px;
      margin-bottom: 2px;
      font-size: 7px;
      color: #666;
    }

    .mem-col-hdr {
      text-align: center;
      padding: 2px 0;
      background: #1a1a1a;
      color: #888;
      font-family: monospace;
    }

    /* Memory legend */
    .mem-legend {
      display: flex;
      gap: 8px;
      font-size: 7px;
      color: #666;
      margin-top: 4px;
      padding: 4px;
      background: #111;
      border-radius: 2px;
      flex-wrap: wrap;
    }

    .mem-region {
      padding: 1px 4px;
      border-radius: 2px;
      font-family: monospace;
    }

    .mem-region.kick { background: #330; color: #880; }
    .mem-region.snare { background: #303; color: #808; }
    .mem-region.lead { background: #033; color: #088; }
    .mem-region.bass { background: #330; color: #880; }
    .mem-region.noise { background: #222; color: #666; }

    /* === GRID UI === */
    .voice-grid {
      margin-bottom: 12px;
    }

    .voice-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .voice-label {
      color: var(--gb-0);
      font-size: 0.7rem;
      font-weight: bold;
    }

    .voice-btns {
      display: flex;
      gap: 4px;
    }

    .voice-btns button {
      padding: 2px 6px;
      font-size: 0.6rem;
      border-width: 1px;
    }

    .grid-row {
      display: grid;
      grid-template-columns: repeat(16, 1fr);
      gap: 2px;
      margin-bottom: 2px;
    }

    .grid-cell {
      aspect-ratio: 1;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      border: 1px solid #2a2a2a;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 6px;
      color: #555;
      user-select: none;
      transition: all 0.1s ease;
      border-radius: 2px;
    }

    .grid-cell:hover {
      border-color: var(--gb-0);
      box-shadow: inset 0 0 10px rgba(155, 188, 15, 0.2);
    }

    .grid-cell.active {
      background: linear-gradient(135deg, var(--gb-2) 0%, #1a4a1a 100%);
      color: var(--gb-0);
      border-color: var(--gb-1);
      box-shadow: 0 0 8px rgba(155, 188, 15, 0.4), inset 0 0 5px rgba(155, 188, 15, 0.2);
      text-shadow: 0 0 4px var(--gb-0);
    }

    .grid-cell.beat {
      background: linear-gradient(135deg, var(--c-acc) 0%, #aa0044 100%);
      border-color: #ff3366;
      box-shadow: 0 0 15px rgba(255, 0, 85, 0.6), inset 0 0 10px rgba(255, 255, 255, 0.2);
      animation: beatPulse 0.1s ease-out;
    }

    @keyframes beatPulse {
      0% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    .param-row {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 2px;
    }

    .param-label {
      font-size: 0.6rem;
      color: #666;
      width: 40px;
    }

    .param-slider {
      flex: 1;
      height: 4px;
      -webkit-appearance: none;
      background: #333;
      border-radius: 2px;
      outline: none;
    }

    .param-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: var(--gb-0);
      border-radius: 50%;
      cursor: pointer;
    }

    /* ADSR compact sliders */
    .adsr-row {
      gap: 2px !important;
    }
    .adsr-slider {
      width: 40px;
      height: 3px;
      -webkit-appearance: none;
      background: #333;
      border-radius: 2px;
      cursor: pointer;
    }
    .adsr-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 8px;
      height: 8px;
      background: var(--gb-2);
      border-radius: 50%;
      cursor: pointer;
    }
    .adsr-slider:hover::-webkit-slider-thumb {
      background: var(--gb-0);
      box-shadow: 0 0 4px var(--gb-0);
    }

    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 8px;
    }

    .tab {
      padding: 4px 10px;
      font-size: 0.7rem;
      background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
      border: 1px solid #444;
      color: #888;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .tab:hover {
      background: rgba(155, 188, 15, 0.2);
      border-color: var(--gb-2);
    }

    .tab.active {
      background: linear-gradient(180deg, var(--gb-2) 0%, #1a4a1a 100%);
      color: var(--gb-0);
      border-color: var(--gb-0);
      box-shadow: 0 0 10px rgba(155, 188, 15, 0.3);
      text-shadow: 0 0 5px var(--gb-0);
    }

    .voice-panel {
      display: none;
    }

    .voice-panel.active {
      display: block;
    }

    /* Scene transition effects */
    .scene-transition {
      animation: sceneSwitch 0.3s ease-out;
    }

    @keyframes sceneSwitch {
      0% { opacity: 0.3; transform: scale(0.98); filter: blur(2px); }
      100% { opacity: 1; transform: scale(1); filter: blur(0); }
    }

    .scene-btn.transitioning {
      animation: scenePulse 0.3s ease-out;
    }

    @keyframes scenePulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); box-shadow: 0 0 20px var(--gb-0); }
      100% { transform: scale(1); }
    }

    .hex-dump {
      background: #000;
      color: var(--gb-0);
      font-family: var(--font), monospace;
      font-size: 13px;
      line-height: 1.6;
      padding: 8px;
      margin: 8px 0 0;
      overflow-x: auto;
      max-height: 280px;
      overflow-y: auto;
    }

    .hex-row {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .hex-addr {
      color: #666;
      width: 50px;
      flex-shrink: 0;
    }

    .hex-byte {
      width: 22px;
      text-align: center;
      cursor: pointer;
      padding: 2px;
      border-radius: 2px;
    }

    .hex-byte:hover {
      background: var(--gb-2);
    }

    .hex-byte.nonzero {
      color: #fff;
      background: var(--gb-3);
    }

    .hex-label {
      color: #555;
      font-size: 10px;
      margin-left: 8px;
    }

    .hex-tooltip {
      position: fixed;
      background: #222;
      border: 1px solid var(--gb-0);
      color: var(--gb-0);
      padding: 6px 10px;
      font-size: 11px;
      border-radius: 4px;
      pointer-events: none;
      z-index: 100;
      max-width: 200px;
    }

    /* EVOLVE PANEL */
    .evolve-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      background: rgba(0,0,0,0.6);
      border: 1px solid var(--c-acc);
      border-radius: 4px;
      margin-top: 4px;
    }

    .evolve-panel.open {
      max-height: 200px;
      padding: 6px;
    }

    .evo-header {
      font-size: 0.6rem;
      color: var(--c-acc);
      text-align: center;
      margin-bottom: 4px;
      letter-spacing: 1px;
    }

    .evo-help {
      cursor: help;
      opacity: 0.6;
    }

    .evo-grid {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .evo-row {
      display: grid;
      grid-template-columns: 44px 50% repeat(7, 22px);
      align-items: center;
      gap: 2px;
      font-size: 0.5rem;
    }

    .evo-row.hdr {
      color: #666;
      text-align: center;
      margin-bottom: 2px;
    }

    .evo-row.hdr span {
      font-size: 0.6rem;
      text-align: center;
    }

    .evo-row label {
      font-size: 0.75rem;
      display: flex;
      align-items: center;
      gap: 2px;
      color: var(--gb-0);
    }

    .evo-row input[type="checkbox"] {
      width: 14px;
      height: 14px;
      accent-color: var(--c-acc);
    }

    .evo-row input[type="range"] {
      width: 100%;
      height: 12px;
      accent-color: var(--c-acc);
    }

    .evo-row.global {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid #333;
      display: flex;
      justify-content: center;
      gap: 12px;
    }

    .evo-row.global select {
      background: #111;
      color: var(--gb-0);
      border: 1px solid #444;
      padding: 2px 4px;
      font-size: 0.55rem;
      font-family: inherit;
    }

    .evo-row.global label {
      color: var(--gb-0);
      font-size: 0.55rem;
    }

    /* Radio group for humanize options */
    .radio-group {
      display: flex;
      gap: 2px;
      background: #111;
      border: 1px solid #333;
      border-radius: 3px;
      padding: 2px;
    }

    .radio-group label {
      padding: 2px 6px;
      cursor: pointer;
      border-radius: 2px;
      transition: all 0.15s;
      color: #666;
      font-size: 0.55rem;
    }

    .radio-group label:has(input:checked) {
      background: var(--gb-2);
      color: var(--gb-0);
    }

    .radio-group input[type="radio"] {
      display: none;
    }

    .lfo-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: linear-gradient(135deg, #222 0%, #111 100%);
      display: inline-block;
      margin-left: 6px;
      border: 1px solid #444;
      transition: all 0.3s ease;
    }

    /* TIMELINE PANEL */
    .timeline-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      background: rgba(0, 20, 0, 0.6);
      border: 1px solid var(--gb-2);
      border-radius: 4px;
      margin-top: 6px;
    }

    .timeline-panel.open {
      max-height: 200px;
      padding: 6px;
    }

    .tl-header {
      font-size: 0.6rem;
      color: var(--gb-0);
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      gap: 6px;
    }

    .tl-title {
      background: #111;
      border: 1px solid #333;
      color: var(--gb-0);
      font-family: var(--font);
      font-size: 0.55rem;
      padding: 2px 6px;
      width: 120px;
      border-radius: 2px;
    }

    .tl-title:focus {
      outline: none;
      border-color: var(--gb-1);
    }

    .tl-help {
      cursor: help;
      opacity: 0.6;
    }

    .tl-btns {
      display: flex;
      gap: 4px;
    }

    .tl-btns button {
      font-size: 0.5rem;
      padding: 2px 6px;
      background: #222;
      color: var(--gb-0);
      border: 1px solid #444;
      border-radius: 2px;
      cursor: pointer;
    }

    .tl-btns button:hover {
      background: #333;
    }

    .tl-output {
      background: #0a0a0a;
      color: var(--gb-1);
      font-size: 0.55rem;
      font-family: var(--font);
      padding: 6px;
      margin: 0;
      width: 100%;
      height: 80px;
      resize: vertical;
      border: 1px solid #222;
      box-sizing: border-box;
    }

    .tl-scrub {
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .scrubber {
      flex: 1;
      height: 8px;
    }

    .scrub-label {
      font-size: 0.5rem;
      color: #666;
    }

    .lfo-indicator.active {
      background: radial-gradient(circle, var(--c-acc) 0%, #aa0033 100%);
      box-shadow: 0 0 10px var(--c-acc), 0 0 20px rgba(255, 0, 85, 0.5);
      animation: lfoGlow 0.5s ease-in-out infinite alternate;
    }

    @keyframes lfoGlow {
      0% { box-shadow: 0 0 10px var(--c-acc), 0 0 20px rgba(255, 0, 85, 0.3); }
      100% { box-shadow: 0 0 15px var(--c-acc), 0 0 30px rgba(255, 0, 85, 0.6); }
    }

    /* Memory cell enhancements */
    .mem-cell.on {
      background: linear-gradient(135deg, var(--gb-2) 0%, #1a4a1a 100%);
      color: var(--gb-0);
      text-shadow: 0 0 3px var(--gb-0);
    }

    .mem-cell.play {
      background: linear-gradient(135deg, var(--c-acc) 0%, #aa0033 100%);
      color: #fff;
      box-shadow: 0 0 8px rgba(255, 0, 85, 0.5);
    }

    /* Memory heat map - glows on recent writes */
    .mem-cell.heat-1 { background: #332200; border-color: #443300; }
    .mem-cell.heat-2 { background: #553300; border-color: #664400; }
    .mem-cell.heat-3 { background: #774400; border-color: #885500; }
    .mem-cell.heat-4 { background: #995500; border-color: #aa6600; }
    .mem-cell.heat-5 { background: #bb6600; border-color: #cc7700; box-shadow: 0 0 4px #ff8800; }
    .mem-cell.heat-6 { background: #dd7700; border-color: #ee8800; box-shadow: 0 0 6px #ffaa00; }
    .mem-cell.heat-7 { background: #ff8800; border-color: #ffaa00; box-shadow: 0 0 8px #ffcc00; color: #000; }
    .mem-cell.heat-8 { background: #ffaa00; border-color: #ffcc00; box-shadow: 0 0 12px #ffee00; color: #000; }

    /* PANIC state - white background, black text */
    #mem-display.panic {
      background: #fff;
      border: 3px solid #f00;
      animation: panic-flash 0.5s infinite;
    }

    @keyframes panic-flash {
      0%, 100% { border-color: #f00; }
      50% { border-color: #ff0; }
    }

    .panic-screen {
      padding: 12px;
      font-family: monospace;
      color: #000;
      text-align: center;
    }

    .panic-header {
      font-size: 14px;
      font-weight: bold;
      color: #c00;
      margin-bottom: 8px;
    }

    .panic-code {
      font-size: 11px;
      color: #000;
      margin: 4px 0;
    }

    .panic-addr, .panic-regs, .panic-dump {
      font-size: 9px;
      color: #333;
      margin: 2px 0;
    }

    .panic-reset {
      margin-top: 8px;
      background: #c00;
      color: #fff;
      border: none;
      padding: 4px 12px;
      cursor: pointer;
      font-weight: bold;
    }

    /* Bus activity indicator */
    .bus-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 9px;
      color: #666;
      margin-top: 4px;
      padding: 4px 8px;
      background: #111;
      border-radius: 2px;
    }

    .bus-led {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #333;
      transition: all 0.05s;
    }

    .bus-led.write {
      background: #f80;
      box-shadow: 0 0 6px #f80;
    }

    .bus-led.read {
      background: #0af;
      box-shadow: 0 0 6px #0af;
    }

    .bus-led.idle {
      background: #333;
    }

    .cpu-state {
      font-family: monospace;
      font-size: 8px;
      color: #888;
    }

    .cpu-state.panic { color: #f00; }
    .cpu-state.break { color: #ff0; }
    .cpu-state.run { color: #0f0; }

    /* Debug trace log */
    .trace-log {
      font-size: 7px;
      font-family: monospace;
      color: #666;
      max-height: 60px;
      overflow-y: auto;
      background: #0a0a0a;
      padding: 4px;
      margin-top: 4px;
      display: none;
    }

    .trace-log.open { display: block; }

    /* Toolchain panel */
    .toolchain-panel {
      background: #0a0a0f;
      border: 1px solid var(--c-cyan);
      border-radius: 4px;
      padding: 8px;
      margin-top: 8px;
    }

    .tc-header {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 6px;
    }

    .tc-btns { display: flex; gap: 4px; }
    .tc-btns button {
      padding: 3px 8px;
      font-size: 0.6rem;
      background: linear-gradient(180deg, #226 0%, #114 100%);
      border-color: var(--c-cyan);
      color: var(--c-cyan);
    }
    .tc-btns button:hover {
      background: linear-gradient(180deg, #338 0%, #225 100%);
    }

    .tc-output {
      width: 100%;
      background: #050505;
      color: #8f8;
      border: 1px solid #333;
      font-family: var(--font);
      resize: vertical;
      padding: 6px;
      box-sizing: border-box;
    }

    .trace-entry { white-space: nowrap; }
    .trace-entry .op-w { color: #f80; }
    .trace-entry .op-r { color: #0af; }

    /* Scene button enhancements */
    .scene-btn.active {
      background: linear-gradient(180deg, var(--gb-0) 0%, var(--gb-1) 100%);
      color: var(--gb-3);
      box-shadow: 0 0 15px rgba(155, 188, 15, 0.5);
    }

    /* Slider track styling */
    .param-slider::-webkit-slider-track {
      background: linear-gradient(90deg, #1a1a1a 0%, #2a2a2a 100%);
      border-radius: 2px;
    }

    .param-slider::-webkit-slider-thumb {
      box-shadow: 0 0 5px var(--gb-0);
    }

    /* Status bar enhancement */
    .status-bar {
      font-size: 0.75rem;
      color: #888;
      text-align: center;
      margin-top: 10px;
      text-shadow: 0 0 5px rgba(155, 188, 15, 0.3);
      padding: 6px;
      border-top: 1px solid rgba(155, 188, 15, 0.1);
    }

    /* Music theory tooltip */
    .theory-toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
      border: 1px solid #9bbc0f;
      border-radius: 8px;
      padding: 12px 20px;
      max-width: 500px;
      z-index: 9999;
      box-shadow: 0 4px 20px rgba(155, 188, 15, 0.3);
      animation: slideUp 0.3s ease;
      font-size: 0.85rem;
    }
    .theory-toast .theory-genre {
      color: #9bbc0f;
      font-weight: bold;
      font-size: 1rem;
      margin-bottom: 4px;
    }
    .theory-toast .theory-text {
      color: #ccc;
      line-height: 1.4;
    }
    @keyframes slideUp {
      from { transform: translateX(-50%) translateY(20px); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    /* ============ BOOT SCREEN ============ */
    #boot-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0f;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: var(--font);
    }

    #boot-screen.fade-out {
      animation: bootFadeOut 0.5s ease-out forwards;
      pointer-events: none;
    }

    @keyframes bootFadeOut {
      to { opacity: 0; }
    }

    .boot-logo {
      font-family: var(--font-head);
      font-size: 3rem;
      color: var(--gb-0);
      text-shadow: 0 0 20px rgba(155, 188, 15, 0.5);
      animation: bootGlow 1.5s ease-in-out infinite alternate;
      margin-bottom: 8px;
    }

    @keyframes bootGlow {
      from { text-shadow: 0 0 10px rgba(155, 188, 15, 0.3); }
      to { text-shadow: 0 0 30px rgba(155, 188, 15, 0.8), 0 0 60px rgba(155, 188, 15, 0.4); }
    }

    .boot-sub {
      font-size: 0.7rem;
      color: #666;
      letter-spacing: 3px;
      margin-bottom: 30px;
    }

    .boot-progress {
      width: 200px;
      height: 4px;
      background: #222;
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .boot-progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--gb-2), var(--gb-0));
      animation: bootLoad 1.8s ease-out forwards;
    }

    @keyframes bootLoad {
      0% { width: 0%; }
      20% { width: 15%; }
      40% { width: 35%; }
      60% { width: 60%; }
      80% { width: 85%; }
      100% { width: 100%; }
    }

    .boot-status {
      font-size: 0.6rem;
      color: var(--gb-2);
      font-family: monospace;
      height: 14px;
    }

    .boot-status::after {
      content: '';
      animation: bootText 1.8s steps(1) forwards;
    }

    @keyframes bootText {
      0% { content: 'INIT MEMORY...'; }
      20% { content: 'LOAD AUDIO...'; }
      40% { content: 'INIT VOICES...'; }
      60% { content: 'LOAD GENRES...'; }
      80% { content: 'READY'; }
      100% { content: 'READY'; }
    }

    .boot-art {
      font-size: 0.5rem;
      color: #333;
      margin-top: 40px;
      text-align: center;
      line-height: 1.2;
      font-family: monospace;
    }
  </style>
</head>

<body>

  <!-- BOOT SCREEN -->
  <div id="boot-screen">
    <div class="boot-logo">$1010</div>
    <div class="boot-sub">SEQUENCER</div>
    <div class="boot-progress"><div class="boot-progress-bar"></div></div>
    <div class="boot-status"></div>
    <div class="boot-art">
      ┌──────────────────────┐<br>
      │  16-BIT   64K RAM    │<br>
      │  MMIO @ $1000-$13FF  │<br>
      │  5-VOICE SYNTHESIS   │<br>
      └──────────────────────┘
    </div>
  </div>

  <h1>$1010 SEQUENCER</h1>
  <div style="color:#666;font-size:0.7rem;margin-bottom:10px;letter-spacing:2px;">$1000-$13FF AUDIO SUBSYSTEM</div>

  <div class="synth-container">
    <div class="screen-bezel">
      <div class="power-led" id="led"></div>
      <canvas id="lcd" width="160" height="144"></canvas>
    </div>

    <div class="controls">
      <!-- PRIMARY: The Job - Play beats, switch scenes -->
      <div class="transport-row">
        <button id="btn-play" class="play-btn" title="Start/stop playback (spacebar)">▶ PLAY</button>
        <div class="tempo-cluster">
          <button id="btn-tempo-down" class="tempo-btn" title="Decrease tempo by 5 BPM">−</button>
          <span id="tempo-display" class="tempo-val">100</span>
          <button id="btn-tempo-up" class="tempo-btn" title="Increase tempo by 5 BPM">+</button>
        </div>
        <div class="scene-cluster">
          <button class="scene-btn active" data-scene="0" title="Scene A: store and recall different patterns (key 1)">A</button>
          <button class="scene-btn" data-scene="1" title="Scene B: store and recall different patterns (key 2)">B</button>
          <button class="scene-btn" data-scene="2" title="Scene C: store and recall different patterns (key 3)">C</button>
          <button class="scene-btn" data-scene="3" title="Scene D: store and recall different patterns (key 4)">D</button>
        </div>
        <span id="bar-display" class="bar-counter">BAR 0</span>
        <button id="btn-rec" class="rec-btn active" title="Record: when active, changes are saved to timeline history">REC</button>
        <button id="btn-tools" class="tools-toggle active" title="Tools: show/hide the tools drawer panel"><span class="icon">⚙</span></button>
      </div>

      <!-- CONTEXT: Genre & Scale info bar -->
      <div class="context-bar">
        <span id="genre-display" class="context-tag">---</span>
        <span id="scale-display" class="context-tag">PENTA</span>
        <span id="swing-display" class="context-tag">SW 0%</span>
        <span id="tuning-display" class="context-tag" title="Tuning system: click TUNE to cycle">12-TET A=440</span>
        <span class="lfo-indicator" id="lfo-led"></span>
        <span id="game-score" class="context-tag" style="display:none;">0</span>
      </div>

      <!-- PROGRESSIVE DISCLOSURE: Tools drawer -->
      <div class="tools-drawer open" id="tools-drawer">
        <div class="tool-groups">
          <div class="tool-group">
            <span class="group-label">STYLE</span>
            <button id="btn-packs" class="pack-btn-open" title="Open pack browser - stack classic machine sounds">PACKS</button>
            <span id="pack-stack-mini" style="font-size:0.45rem;color:var(--gb-1);max-width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></span>
            <button id="btn-genre" class="tool-btn" title="Genre: cycle through preset rhythm patterns (house, techno, hip-hop, etc.)">GEN</button>
            <button id="btn-scale" class="tool-btn" title="Scale: cycle musical scales for melodic voices (pentatonic, minor, etc.)">SCL</button>
            <button id="btn-swing-up" class="tool-btn" title="Swing+: add groove by delaying off-beat notes (+10%)">SW+</button>
            <button id="btn-swing-down" class="tool-btn" title="Swing-: reduce groove swing (-10%)">SW−</button>
            <button id="btn-tuning" class="tool-btn" title="Tuning: cycle tuning systems (12-TET, Just Intonation, Pythagorean, Colundi)">TUNE</button>
            <button id="btn-a4-up" class="tool-btn" title="A4 reference pitch +1Hz (default 440Hz)">A4+</button>
            <button id="btn-a4-down" class="tool-btn" title="A4 reference pitch -1Hz">A4−</button>
          </div>
          <div class="tool-group">
            <span class="group-label">EDIT</span>
            <button id="btn-mutate" class="tool-btn" title="Random: randomly modify pattern based on evolve settings">RND</button>
            <button id="btn-copy" class="tool-btn" title="Copy: duplicate current scene to next scene slot">CPY</button>
            <button id="btn-rotate-l" class="tool-btn" title="Rotate Left: shift all patterns one step earlier">◀</button>
            <button id="btn-rotate-r" class="tool-btn" title="Rotate Right: shift all patterns one step later">▶</button>
            <button id="btn-invert" class="tool-btn" title="Invert: flip all steps (on↔off) for all voices">INV</button>
            <button id="btn-life" class="tool-btn" title="Cellular Automata: apply Conway's Game of Life rules to pattern">CA</button>
          </div>
          <div class="tool-group">
            <span class="group-label">MODE</span>
            <button id="btn-evolve" class="tool-btn evolve-active active" title="Evolve: auto-mutate patterns over time while playing">EVO</button>
            <button id="btn-lfo" class="tool-btn" title="LFO: low-frequency oscillator modulates bass and noise params">LFO</button>
            <button id="btn-timeline" class="tool-btn" title="Timeline: view session history as code, undo/redo, export">TL</button>
            <button id="btn-toolchain" class="tool-btn" title="Toolchain: compile DSL to MTMC-16/WASM/C/Rust" style="color:var(--c-cyan);">TC</button>
          </div>
        </div>
      </div>

      <!-- EVOLVE CONFIG PANEL -->
      <div class="evolve-panel open" id="evolve-panel">
        <div class="evo-header">EVOLVE CONFIG</div>
        <div class="evo-grid">
          <div class="evo-row hdr"><span></span><span title="Mutation amount: how aggressively this voice evolves (0-100%)">AMT</span><span title="Shift: randomly move pattern left or right by 1-2 steps">SHF</span><span title="Add/Remove: randomly toggle steps on or off">±</span><span title="Octave: transpose notes up or down by octave (melodic voices only)">OCT</span><span title="Reverse: flip the entire pattern backwards">REV</span><span title="Probability: randomize step trigger probability (0-100%)">PRB</span><span title="Ratchet: add rapid-fire repeats (2-4x) to random steps">RAT</span><span title="Swap: exchange patterns between two voices">SWP</span></div>
          <div class="evo-row" data-v="kick"><label title="Kick drum: low sine wave thump, forms the rhythmic foundation"><input type="checkbox" class="evo-on" checked>KCK</label><input type="range" class="evo-amt" min="0" max="100" value="5"><input type="checkbox" class="evo-shift"><input type="checkbox" class="evo-addrm"><input type="checkbox" class="evo-oct" checked><input type="checkbox" class="evo-rev"><input type="checkbox" class="evo-prob"><input type="checkbox" class="evo-ratch"><input type="checkbox" class="evo-swap"></div>
          <div class="evo-row" data-v="snare"><label title="Snare drum: noise burst with tonal snap, provides backbeat"><input type="checkbox" class="evo-on" checked>SNR</label><input type="range" class="evo-amt" min="0" max="100" value="10"><input type="checkbox" class="evo-shift"><input type="checkbox" class="evo-addrm"><input type="checkbox" class="evo-oct" checked><input type="checkbox" class="evo-rev"><input type="checkbox" class="evo-prob"><input type="checkbox" class="evo-ratch"><input type="checkbox" class="evo-swap"></div>
          <div class="evo-row" data-v="lead"><label title="Lead synth: melodic voice playing notes in the current scale"><input type="checkbox" class="evo-on" checked>LED</label><input type="range" class="evo-amt" min="0" max="100" value="85"><input type="checkbox" class="evo-shift" checked><input type="checkbox" class="evo-addrm" checked><input type="checkbox" class="evo-oct" checked><input type="checkbox" class="evo-rev" checked><input type="checkbox" class="evo-prob"><input type="checkbox" class="evo-ratch"><input type="checkbox" class="evo-swap"></div>
          <div class="evo-row" data-v="bass"><label title="Bass synth: low FM voice providing harmonic foundation"><input type="checkbox" class="evo-on" checked>BAS</label><input type="range" class="evo-amt" min="0" max="100" value="70"><input type="checkbox" class="evo-shift" checked><input type="checkbox" class="evo-addrm" checked><input type="checkbox" class="evo-oct" checked><input type="checkbox" class="evo-rev"><input type="checkbox" class="evo-prob"><input type="checkbox" class="evo-ratch"><input type="checkbox" class="evo-swap"></div>
          <div class="evo-row" data-v="noise"><label title="Noise/hihat: filtered noise for percussive texture and groove"><input type="checkbox" class="evo-on" checked>NOS</label><input type="range" class="evo-amt" min="0" max="100" value="35"><input type="checkbox" class="evo-shift" checked><input type="checkbox" class="evo-addrm" checked><input type="checkbox" class="evo-oct"><input type="checkbox" class="evo-rev" checked><input type="checkbox" class="evo-prob" checked><input type="checkbox" class="evo-ratch" checked><input type="checkbox" class="evo-swap" checked></div>
        </div>
        <div class="evo-row global">
          <select class="evo-interval" title="Evolution interval: how many steps between mutations (lower = faster evolution)"><option value="8" selected>8 stp</option><option value="16">16 stp</option><option value="32">32 stp</option><option value="64">64 stp</option></select>
          <span class="radio-group humanize-group" title="Humanize: add timing imperfection for organic feel">
            <label title="No timing variation"><input type="radio" name="humanize" value="0">OFF</label>
            <label title="Subtle timing drift (±5ms)"><input type="radio" name="humanize" value="1">LITE</label>
            <label title="Natural timing feel (±15ms)"><input type="radio" name="humanize" value="2" checked>FULL</label>
          </span>
        </div>
        <div class="evo-row global">
          <label title="Density bias: negative removes steps, positive adds steps (-50 to +50)">DNS<input type="range" class="evo-density" min="-50" max="50" value="0" style="width:50px"></label>
          <label title="Chaos: how wild mutations get (1=subtle, 10=dramatic)">CHS<input type="range" class="evo-chaos" min="1" max="10" value="3" style="width:50px"></label>
          <label title="Lock root: preserve bass/lead root notes during evolution"><input type="checkbox" class="evo-lock">LOCK</label>
          <label title="Chain: auto-advance to next scene after each evolution cycle"><input type="checkbox" class="evo-chain">CHAIN</label>
        </div>
      </div>

      <!-- TIMELINE PANEL - Educational: See your session as code! -->
      <div class="timeline-panel" id="timeline-panel">
        <div class="tl-header">
          <input type="text" id="tl-title" class="tl-title" value="Untitled Session" placeholder="Session title">
          <span class="tl-help" title="Records your session as a DSL script. Edit and reload!">?</span>
          <div class="tl-btns">
            <button id="tl-undo" title="Undo: revert to previous state in session history" disabled>UND</button>
            <button id="tl-redo" title="Redo: restore next state in session history" disabled>RED</button>
            <button id="tl-snap" title="Snapshot: save current state to timeline">SNAP</button>
            <button id="tl-clear" title="Clear: erase all timeline history">CLR</button>
            <button id="tl-copy" title="Copy DSL: copy session code to clipboard">COPY</button>
            <button id="tl-load" title="Load DSL or mini format (BPM:120, 1000:x...) from textarea">LOAD</button>
            <button id="tl-midi" title="Export MIDI: download 4-bar MIDI file">MIDI</button>
            <button id="tl-wav" title="Export WAV: download 4-bar audio file">WAV</button>
          </div>
        </div>
        <textarea id="timeline-output" class="tl-output" spellcheck="false">$1010 SONG v1
@title "Untitled Session"
@tempo 100
# Press PLAY and make changes to record...</textarea>
        <div class="tl-scrub">
          <input type="range" id="tl-scrubber" min="0" max="0" value="0" class="scrubber" disabled>
          <span class="scrub-label">SCRUB (coming soon)</span>
        </div>
      </div>

      <!-- TOOLCHAIN PANEL - Compile to multiple targets -->
      <div class="toolchain-panel" id="toolchain-panel" style="display:none;">
        <div class="tc-header">
          <span style="color:var(--gb-0);font-size:0.7rem;">$1010 COMPILER</span>
          <select id="tc-target" style="background:#222;color:var(--gb-0);border:1px solid #444;font-size:0.6rem;padding:2px 4px;">
            <option value="mtmc16">MTMC-16 ASM</option>
            <option value="wasm">WASM (.wat)</option>
            <option value="c">C (embedded)</option>
            <option value="rust">Rust (embedded)</option>
            <option value="hex">Intel HEX</option>
          </select>
          <div class="tc-btns">
            <button onclick="compileAndShow()" title="Compile DSL to selected target">COMPILE</button>
            <button onclick="downloadCompiled()" title="Download compiled output">SAVE</button>
            <button onclick="copyCompiled()" title="Copy to clipboard">COPY</button>
          </div>
        </div>
        <div class="tc-status" id="tc-status" style="font-size:0.6rem;color:#666;padding:4px 0;"></div>
        <textarea id="tc-output" class="tc-output" readonly spellcheck="false" style="height:180px;font-size:0.55rem;background:#050505;color:#8f8;"></textarea>
      </div>
    </div>

    <div class="code-block">
      <div class="label-row">
        <span>PATTERN EDITOR</span>
        <span>MEMORY MAP: $1000-$13FF</span>
      </div>

      <div class="tabs">
        <div class="tab active" data-voice="kick">KICK</div>
        <div class="tab" data-voice="snare">SNARE</div>
        <div class="tab" data-voice="lead">LEAD</div>
        <div class="tab" data-voice="bass">BASS</div>
        <div class="tab" data-voice="noise">NOISE</div>
      </div>

      <!-- KICK PANEL -->
      <div class="voice-panel active" id="panel-kick">
        <div class="voice-header">
          <span class="voice-label">$1000 KICK GATE</span>
          <div class="voice-btns">
            <button onclick="randomizeVoice('kick')" title="Random: generate random pattern for this voice">RND</button>
            <button onclick="trueEuclidVoice('kick', event)" title="Euclidean: mathematically distribute N hits across 16 steps">EUC</button>
            <button onclick="euclidVoice('kick')" title="Pattern: apply genre-specific preset pattern">PAT</button>
            <button onclick="clearVoice('kick')" title="Clear: remove all steps from this voice">CLR</button>
          </div>
        </div>
        <div class="grid-row" id="grid-kick"></div>
        <div class="param-row">
          <span class="param-label">PITCH</span>
          <input type="range" class="param-slider" id="param-kick-pitch" min="24" max="60" value="36">
          <span id="val-kick-pitch" style="color:#666;font-size:0.6rem;width:30px">36</span>
        </div>
        <div class="param-row">
          <span class="param-label">PROB%</span>
          <input type="range" class="param-slider prob-slider" id="param-kick-prob" data-voice="kick" min="0" max="100" value="0">
          <span id="val-kick-prob" style="color:#666;font-size:0.6rem;width:30px">100</span>
        </div>
        <div class="param-row">
          <span class="param-label">RATCH</span>
          <input type="range" class="param-slider ratch-slider" id="param-kick-ratch" data-voice="kick" min="1" max="8" value="1">
          <span id="val-kick-ratch" style="color:#666;font-size:0.6rem;width:30px">1</span>
        </div>
        <div class="param-row adsr-row">
          <span class="param-label">ADSR</span>
          <input type="range" class="adsr-slider" id="adsr-kick-a" data-voice="kick" data-param="0" min="0" max="255" value="5" title="Attack">
          <input type="range" class="adsr-slider" id="adsr-kick-d" data-voice="kick" data-param="1" min="0" max="255" value="20" title="Decay">
          <input type="range" class="adsr-slider" id="adsr-kick-s" data-voice="kick" data-param="2" min="0" max="255" value="0" title="Sustain">
          <input type="range" class="adsr-slider" id="adsr-kick-r" data-voice="kick" data-param="3" min="0" max="255" value="50" title="Release">
        </div>
      </div>

      <!-- SNARE PANEL -->
      <div class="voice-panel" id="panel-snare">
        <div class="voice-header">
          <span class="voice-label">$1020 SNARE GATE</span>
          <div class="voice-btns">
            <button onclick="randomizeVoice('snare')" title="Random: generate random pattern for this voice">RND</button>
            <button onclick="trueEuclidVoice('snare', event)" title="Euclidean: mathematically distribute N hits across 16 steps">EUC</button>
            <button onclick="euclidVoice('snare')" title="Pattern: apply genre-specific preset pattern">PAT</button>
            <button onclick="clearVoice('snare')" title="Clear: remove all steps from this voice">CLR</button>
          </div>
        </div>
        <div class="grid-row" id="grid-snare"></div>
        <div class="param-row">
          <span class="param-label">TONE</span>
          <input type="range" class="param-slider" id="param-snare-tone" min="100" max="300" value="180">
          <span id="val-snare-tone" style="color:#666;font-size:0.6rem;width:30px">180</span>
        </div>
        <div class="param-row">
          <span class="param-label">SNAP</span>
          <input type="range" class="param-slider" id="param-snare-snap" min="30" max="200" value="100">
          <span id="val-snare-snap" style="color:#666;font-size:0.6rem;width:30px">100</span>
        </div>
        <div class="param-row">
          <span class="param-label">PROB%</span>
          <input type="range" class="param-slider prob-slider" id="param-snare-prob" data-voice="snare" min="0" max="100" value="0">
          <span id="val-snare-prob" style="color:#666;font-size:0.6rem;width:30px">100</span>
        </div>
        <div class="param-row">
          <span class="param-label">RATCH</span>
          <input type="range" class="param-slider ratch-slider" id="param-snare-ratch" data-voice="snare" min="1" max="8" value="1">
          <span id="val-snare-ratch" style="color:#666;font-size:0.6rem;width:30px">1</span>
        </div>
        <div class="param-row adsr-row">
          <span class="param-label">ADSR</span>
          <input type="range" class="adsr-slider" id="adsr-snare-a" data-voice="snare" data-param="0" min="0" max="255" value="0" title="Attack">
          <input type="range" class="adsr-slider" id="adsr-snare-d" data-voice="snare" data-param="1" min="0" max="255" value="30" title="Decay">
          <input type="range" class="adsr-slider" id="adsr-snare-s" data-voice="snare" data-param="2" min="0" max="255" value="0" title="Sustain">
          <input type="range" class="adsr-slider" id="adsr-snare-r" data-voice="snare" data-param="3" min="0" max="255" value="80" title="Release">
        </div>
      </div>

      <!-- LEAD PANEL -->
      <div class="voice-panel" id="panel-lead">
        <div class="voice-header">
          <span class="voice-label">$1100 LEAD NOTE</span>
          <div class="voice-btns">
            <button onclick="randomizeVoice('lead')" title="Random: generate random melodic pattern in current scale">RND</button>
            <button onclick="trueEuclidVoice('lead', event)" title="Euclidean: mathematically distribute N notes across 16 steps">EUC</button>
            <button onclick="euclidVoice('lead')" title="Pattern: apply genre-specific melodic pattern">PAT</button>
            <button onclick="clearVoice('lead')" title="Clear: remove all notes from this voice">CLR</button>
          </div>
        </div>
        <div class="grid-row" id="grid-lead"></div>
        <div class="param-row">
          <span class="param-label">NOTE</span>
          <input type="range" class="param-slider" id="param-lead-note" min="48" max="84" value="60">
          <span id="val-lead-note" style="color:#666;font-size:0.6rem;width:30px">C4</span>
        </div>
        <div class="param-row">
          <span class="param-label">ARP</span>
          <select id="param-lead-arp" style="background:#222;color:var(--gb-0);border:1px solid #444;font-size:0.6rem;">
            <option value="0">OFF</option>
            <option value="1">MAJ</option>
            <option value="2">MIN</option>
          </select>
        </div>
        <div class="param-row">
          <span class="param-label">PROB%</span>
          <input type="range" class="param-slider prob-slider" id="param-lead-prob" data-voice="lead" min="0" max="100" value="0">
          <span id="val-lead-prob" style="color:#666;font-size:0.6rem;width:30px">100</span>
        </div>
        <div class="param-row">
          <span class="param-label">RATCH</span>
          <input type="range" class="param-slider ratch-slider" id="param-lead-ratch" data-voice="lead" min="1" max="8" value="1">
          <span id="val-lead-ratch" style="color:#666;font-size:0.6rem;width:30px">1</span>
        </div>
        <div class="param-row adsr-row">
          <span class="param-label">ADSR</span>
          <input type="range" class="adsr-slider" id="adsr-lead-a" data-voice="lead" data-param="0" min="0" max="255" value="10" title="Attack">
          <input type="range" class="adsr-slider" id="adsr-lead-d" data-voice="lead" data-param="1" min="0" max="255" value="40" title="Decay">
          <input type="range" class="adsr-slider" id="adsr-lead-s" data-voice="lead" data-param="2" min="0" max="255" value="128" title="Sustain">
          <input type="range" class="adsr-slider" id="adsr-lead-r" data-voice="lead" data-param="3" min="0" max="255" value="60" title="Release">
        </div>
        <div class="param-row">
          <span class="param-label">DETUNE</span>
          <input type="range" class="param-slider detune-slider" id="detune-lead" data-voice="2" min="-50" max="50" value="0" title="Fine tune in cents (±50)">
          <span id="val-detune-lead" style="color:#666;font-size:0.6rem;width:30px">0¢</span>
        </div>
      </div>

      <!-- BASS PANEL -->
      <div class="voice-panel" id="panel-bass">
        <div class="voice-header">
          <span class="voice-label">$1200 BASS NOTE</span>
          <div class="voice-btns">
            <button onclick="randomizeVoice('bass')" title="Random: generate random bass line in current scale">RND</button>
            <button onclick="trueEuclidVoice('bass', event)" title="Euclidean: mathematically distribute N notes across 16 steps">EUC</button>
            <button onclick="euclidVoice('bass')" title="Pattern: apply genre-specific bass pattern">PAT</button>
            <button onclick="clearVoice('bass')" title="Clear: remove all notes from this voice">CLR</button>
          </div>
        </div>
        <div class="grid-row" id="grid-bass"></div>
        <div class="param-row">
          <span class="param-label">NOTE</span>
          <input type="range" class="param-slider" id="param-bass-note" min="24" max="48" value="36">
          <span id="val-bass-note" style="color:#666;font-size:0.6rem;width:30px">C2</span>
        </div>
        <div class="param-row">
          <span class="param-label">FM</span>
          <input type="range" class="param-slider" id="param-bass-fm" min="0" max="127" value="40">
          <span id="val-bass-fm" style="color:#666;font-size:0.6rem;width:30px">40</span>
        </div>
        <div class="param-row">
          <span class="param-label">FILT</span>
          <input type="range" class="param-slider" id="param-bass-filt" min="0" max="127" value="70">
          <span id="val-bass-filt" style="color:#666;font-size:0.6rem;width:30px">70</span>
        </div>
        <div class="param-row">
          <span class="param-label">PROB%</span>
          <input type="range" class="param-slider prob-slider" id="param-bass-prob" data-voice="bass" min="0" max="100" value="0">
          <span id="val-bass-prob" style="color:#666;font-size:0.6rem;width:30px">100</span>
        </div>
        <div class="param-row">
          <span class="param-label">RATCH</span>
          <input type="range" class="param-slider ratch-slider" id="param-bass-ratch" data-voice="bass" min="1" max="8" value="1">
          <span id="val-bass-ratch" style="color:#666;font-size:0.6rem;width:30px">1</span>
        </div>
        <div class="param-row adsr-row">
          <span class="param-label">ADSR</span>
          <input type="range" class="adsr-slider" id="adsr-bass-a" data-voice="bass" data-param="0" min="0" max="255" value="5" title="Attack">
          <input type="range" class="adsr-slider" id="adsr-bass-d" data-voice="bass" data-param="1" min="0" max="255" value="30" title="Decay">
          <input type="range" class="adsr-slider" id="adsr-bass-s" data-voice="bass" data-param="2" min="0" max="255" value="180" title="Sustain">
          <input type="range" class="adsr-slider" id="adsr-bass-r" data-voice="bass" data-param="3" min="0" max="255" value="40" title="Release">
        </div>
        <div class="param-row">
          <span class="param-label">DETUNE</span>
          <input type="range" class="param-slider detune-slider" id="detune-bass" data-voice="3" min="-50" max="50" value="0" title="Fine tune in cents (±50)">
          <span id="val-detune-bass" style="color:#666;font-size:0.6rem;width:30px">0¢</span>
        </div>
      </div>

      <!-- NOISE PANEL -->
      <div class="voice-panel" id="panel-noise">
        <div class="voice-header">
          <span class="voice-label">$1300 NOISE GATE</span>
          <div class="voice-btns">
            <button onclick="randomizeVoice('noise')" title="Random: generate random hihat/noise pattern">RND</button>
            <button onclick="trueEuclidVoice('noise', event)" title="Euclidean: mathematically distribute N hits across 16 steps">EUC</button>
            <button onclick="euclidVoice('noise')" title="Pattern: apply genre-specific hihat pattern">PAT</button>
            <button onclick="clearVoice('noise')" title="Clear: remove all steps from this voice">CLR</button>
          </div>
        </div>
        <div class="grid-row" id="grid-noise"></div>
        <div class="param-row">
          <span class="param-label">DECAY</span>
          <input type="range" class="param-slider" id="param-noise-y" min="1" max="15" value="14">
          <span id="val-noise-y" style="color:#666;font-size:0.6rem;width:30px">14</span>
        </div>
        <div class="param-row">
          <span class="param-label">TYPE</span>
          <select id="param-noise-type" style="background:#222;color:var(--gb-0);border:1px solid #444;font-size:0.6rem;">
            <option value="0">HAT</option>
            <option value="1">ZAP</option>
          </select>
        </div>
        <div class="param-row">
          <span class="param-label">PROB%</span>
          <input type="range" class="param-slider prob-slider" id="param-noise-prob" data-voice="noise" min="0" max="100" value="0">
          <span id="val-noise-prob" style="color:#666;font-size:0.6rem;width:30px">100</span>
        </div>
        <div class="param-row">
          <span class="param-label">RATCH</span>
          <input type="range" class="param-slider ratch-slider" id="param-noise-ratch" data-voice="noise" min="1" max="8" value="1">
          <span id="val-noise-ratch" style="color:#666;font-size:0.6rem;width:30px">1</span>
        </div>
        <div class="param-row adsr-row">
          <span class="param-label">ADSR</span>
          <input type="range" class="adsr-slider" id="adsr-noise-a" data-voice="noise" data-param="0" min="0" max="255" value="0" title="Attack">
          <input type="range" class="adsr-slider" id="adsr-noise-d" data-voice="noise" data-param="1" min="0" max="255" value="60" title="Decay">
          <input type="range" class="adsr-slider" id="adsr-noise-s" data-voice="noise" data-param="2" min="0" max="255" value="0" title="Sustain">
          <input type="range" class="adsr-slider" id="adsr-noise-r" data-voice="noise" data-param="3" min="0" max="255" value="30" title="Release">
        </div>
      </div>

      <div class="status-bar" id="status">READY. INIT AUDIO → PLAY</div>
    </div>

    <div class="code-block">
      <div class="label-row">
        <span>RAM MONITOR</span>
        <div class="voice-btns">
          <button onclick="exportData()" title="JSON: export all scenes as JSON file + clipboard">JSON</button>
          <button onclick="importData()" title="Load: import JSON data from clipboard">LOAD</button>
          <button onclick="exportASM()" title="ASM: export as MTMC-16 assembly code (.asm)">ASM</button>
          <button onclick="exportWAV(4)" title="WAV: render and download 4 bars as audio file">WAV</button>
          <button onclick="exportMIDI(4)" title="MIDI: export 4 bars as standard MIDI file">MIDI</button>
          <button onclick="importMIDI()" title="Import: load a MIDI file into the sequencer">IMP</button>
          <button onclick="toggleHex()" title="HEX: show/hide raw memory as hexadecimal dump">HEX</button>
          <button onclick="toggleTrace()" title="Trace: toggle debug logging to console">TRC</button>
          <button onclick="testPanic()" title="Panic: trigger test crash screen (for debugging)">!</button>
          <button onclick="clearStorage()" title="Clear: erase all saved data from browser storage">CLR</button>
          <input type="file" id="midi-file-input" accept=".mid,.midi" style="display:none">
        </div>
      </div>
      <div class="bus-status">
        <div id="bus-indicator" class="bus-led idle"></div>
        <span id="bus-addr">$0000</span>
        <span id="cpu-state" class="cpu-state run">RUN</span>
        <span id="cpu-cycles">CYC:0</span>
        <span id="bus-rw">R:0 W:0</span>
      </div>
      <div id="mem-display"></div>
      <div id="trace-log" class="trace-log"></div>
      <pre id="hex-dump" class="hex-dump" style="display:none;"></pre>
    </div>
  </div>

  <!-- Pack Browser Modal -->
  <div id="pack-overlay" class="pack-overlay"></div>
  <div id="pack-browser" class="pack-browser">
    <div class="pack-browser-header">
      <span class="pack-browser-title">PACK BROWSER</span>
      <button class="pack-browser-close" id="pack-browser-close">&times;</button>
    </div>
    <div class="pack-stack" id="pack-stack">
      <div class="pack-stack-label">LOADED PACKS (click to remove)</div>
      <!-- Chips appear here -->
    </div>
    <div class="pack-facets" id="pack-facets">
      <button class="pack-facet active" data-cat="all">ALL</button>
      <button class="pack-facet drums" data-cat="drums">DRUMS</button>
      <button class="pack-facet synth" data-cat="synth">SYNTHS</button>
      <button class="pack-facet sampler" data-cat="sampler">SAMPLERS</button>
      <button class="pack-facet genre" data-cat="genre">GENRES</button>
    </div>
    <div class="pack-grid" id="pack-grid">
      <!-- Pack items populated by JS -->
    </div>
    <div class="pack-mode-bar">
      <label>MODE:</label>
      <button class="pack-mode-btn" data-mode="replace" title="Replace: clear all and load fresh">RPL</button>
      <button class="pack-mode-btn active" data-mode="or" title="OR: merge with existing (non-zero wins)">OR</button>
      <button class="pack-mode-btn" data-mode="and" title="AND: only where both have values">AND</button>
      <button class="pack-mode-btn" data-mode="drums" title="Drums only: just load drum params">DRM</button>
      <button class="pack-mode-btn" data-mode="synth" title="Synth only: just load synth params">SYN</button>
    </div>
  </div>

  <script>
    // ============ 16-BIT VIRTUAL MACHINE ============
    const MEM = new Uint8Array(65536);

    // ============ MEMORY BUS & DEBUG TRACKING ============
    const MEM_HEAT = new Uint8Array(65536);     // Write heat (0-255, decays over time)
    const MEM_WRITES = new Uint32Array(65536);  // Total write count per address
    const MEM_READS = new Uint32Array(65536);   // Total read count per address

    const BUS = {
      active: false,
      lastAddr: 0,
      lastOp: 'IDLE',  // 'READ', 'WRITE', 'IDLE'
      cycles: 0,
      bytesWritten: 0,
      bytesRead: 0
    };

    const CPU = {
      cycles: 0,
      state: 'RUN',    // 'RUN', 'HALT', 'PANIC', 'BREAK'
      pc: 0x0000,      // Program counter (simulated)
      sp: 0xFFFF,      // Stack pointer
      irq: false,
      nmi: false
    };

    const PANIC = {
      active: false,
      code: 0,
      message: '',
      addr: 0,
      dump: []
    };

    const DEBUG = {
      breakpoints: new Set(),  // Addresses to break on write
      watchpoints: new Set(),  // Addresses to watch
      traceLog: [],            // Recent memory operations
      traceMax: 100,
      enabled: false,
      paused: false
    };

    // Memory write with tracking
    function memWrite(addr, value) {
      if (PANIC.active) return;

      // Bounds check - trigger PANIC on invalid address
      if (addr < 0 || addr >= 65536) {
        triggerPanic(0x01, 'SEGFAULT: INVALID ADDR', addr);
        return;
      }

      // Track the write
      BUS.active = true;
      BUS.lastAddr = addr;
      BUS.lastOp = 'WRITE';
      BUS.cycles++;
      BUS.bytesWritten++;
      CPU.cycles++;

      MEM_HEAT[addr] = 255;  // Max heat on write
      MEM_WRITES[addr]++;

      // Check for breakpoints
      if (DEBUG.breakpoints.has(addr)) {
        DEBUG.paused = true;
        CPU.state = 'BREAK';
        document.getElementById('status').innerText = `BREAK @ $${addr.toString(16).toUpperCase().padStart(4, '0')}`;
      }

      // Trace log
      if (DEBUG.enabled) {
        DEBUG.traceLog.unshift({
          cycle: CPU.cycles,
          op: 'W',
          addr: addr,
          val: value,
          prev: MEM[addr]
        });
        if (DEBUG.traceLog.length > DEBUG.traceMax) DEBUG.traceLog.pop();
      }

      // Stack overflow detection (if writing below SP in stack region)
      if (addr >= 0xF000 && addr < CPU.sp - 256) {
        triggerPanic(0x02, 'STACK OVERFLOW', addr);
        return;
      }

      MEM[addr] = value;
      updateBusIndicator();
    }

    // Memory read with tracking
    function memRead(addr) {
      if (addr < 0 || addr >= 65536) {
        triggerPanic(0x01, 'SEGFAULT: INVALID READ', addr);
        return 0;
      }

      BUS.active = true;
      BUS.lastAddr = addr;
      BUS.lastOp = 'READ';
      BUS.bytesRead++;
      CPU.cycles++;

      MEM_READS[addr]++;

      return MEM[addr];
    }

    // PANIC - system crash
    function triggerPanic(code, message, addr) {
      PANIC.active = true;
      PANIC.code = code;
      PANIC.message = message;
      PANIC.addr = addr;
      PANIC.dump = Array.from(MEM.slice(Math.max(0, addr - 8), Math.min(65536, addr + 8)));

      CPU.state = 'PANIC';
      isPlaying = false;
      clearTimeout(timer);

      renderPanicScreen();
    }

    function renderPanicScreen() {
      const md = document.getElementById('mem-display');
      md.classList.add('panic');
      md.innerHTML = `
        <div class="panic-screen">
          <div class="panic-header">*** SYSTEM PANIC ***</div>
          <div class="panic-code">ERR $${PANIC.code.toString(16).toUpperCase().padStart(2, '0')}: ${PANIC.message}</div>
          <div class="panic-addr">ADDR: $${PANIC.addr.toString(16).toUpperCase().padStart(4, '0')}</div>
          <div class="panic-regs">PC:$${CPU.pc.toString(16).padStart(4,'0')} SP:$${CPU.sp.toString(16).padStart(4,'0')} CYC:${CPU.cycles}</div>
          <div class="panic-dump">DUMP: ${PANIC.dump.map(b => b.toString(16).padStart(2, '0')).join(' ')}</div>
          <button onclick="resetPanic()" class="panic-reset" title="Reset: clear panic state and resume normal operation">RST</button>
        </div>
      `;

      // Flash the LCD
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, 160, 144);
      ctx.fillStyle = '#000';
      ctx.font = '10px monospace';
      ctx.fillText('PANIC', 60, 70);
      ctx.fillText('$' + PANIC.code.toString(16).toUpperCase().padStart(2, '0'), 68, 85);
    }

    function resetPanic() {
      PANIC.active = false;
      PANIC.code = 0;
      PANIC.message = '';
      CPU.state = 'RUN';

      document.getElementById('mem-display').classList.remove('panic');
      initMem();
      syncGridsFromMem();
      updateMemDisplay();
      document.getElementById('status').innerText = 'SYSTEM RESET';
    }

    // Decay heat over time
    function decayHeat() {
      for (let i = 0; i < 65536; i++) {
        if (MEM_HEAT[i] > 0) {
          MEM_HEAT[i] = Math.max(0, MEM_HEAT[i] - 8);
        }
      }
    }

    // Update bus activity indicator
    function updateBusIndicator() {
      const indicator = document.getElementById('bus-indicator');
      if (indicator) {
        indicator.className = 'bus-led ' + BUS.lastOp.toLowerCase();
        setTimeout(() => {
          BUS.active = false;
          BUS.lastOp = 'IDLE';
          indicator.className = 'bus-led idle';
        }, 50);
      }
    }

    const canvas = document.getElementById('lcd');
    const ctx = canvas.getContext('2d');
    const C = ['#9bbc0f', '#8bac0f', '#306230', '#0f380f'];
    let audioCtx = null;
    let isPlaying = false;
    let step = 0;
    let tempo = 100;
    let swing = 0; // 0% = straight, 50% = shuffle, 75% = hard swing
    let eucModes = { kick: 0, snare: 0, noise: 0, lead: 0, bass: 0 };
    let nextTime = 0;
    let timer = null;
    let selectedStep = -1;
    let currentScene = 0;
    let copyMode = false;

    // Scene memory: 4 scenes × 1024 bytes each ($1000-$13FF range)
    const SCENES = [
      new Uint8Array(1024),
      new Uint8Array(1024),
      new Uint8Array(1024),
      new Uint8Array(1024)
    ];

    // ============ LOCAL STORAGE ============
    const STORAGE_KEY = '1010seq_state';
    let autoSaveTimer = null;

    let baseGenre = null; // Track the base genre name for display

    function saveToLocalStorage() {
      try {
        const data = {
          version: '1010seq-v2',
          tempo: tempo,
          swing: swing,
          currentScene: currentScene,
          currentScale: Object.keys(SCALES).find(k => SCALES[k] === currentScale) || 'PENTA',
          baseGenre: baseGenre,
          scenes: SCENES.map(s => Array.from(s))
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch (e) {
        console.warn('LocalStorage save failed:', e);
      }
    }

    function loadFromLocalStorage() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) return false;

        const data = JSON.parse(stored);
        if (!data.version || !data.version.startsWith('1010seq')) return false;

        tempo = data.tempo || 100;
        swing = data.swing || 0;
        currentScene = data.currentScene || 0;

        if (data.currentScale && SCALES[data.currentScale]) {
          currentScale = SCALES[data.currentScale];
        }

        // Restore base genre name
        baseGenre = data.baseGenre || null;

        data.scenes.forEach((sceneData, i) => {
          if (sceneData && SCENES[i]) {
            SCENES[i].set(sceneData);
          }
        });

        return true;
      } catch (e) {
        console.warn('LocalStorage load failed:', e);
        return false;
      }
    }

    function scheduleAutoSave() {
      // Debounce saves to avoid hammering localStorage
      if (autoSaveTimer) clearTimeout(autoSaveTimer);
      autoSaveTimer = setTimeout(saveToLocalStorage, 500);
    }

    // ============ QUICK WIN HELPERS ============
    // Scale helper: note('C', 4) => 60
    const note = (n, o = 4) => ({ C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 }[n.toUpperCase()] || 0) + 12 * (o + 1);
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const midiToName = m => noteNames[m % 12] + Math.floor(m / 12 - 1);

    // ============ TRUE EUCLIDEAN (BJORKLUND'S ALGORITHM) ============
    // Distributes N pulses across K steps as evenly as possible
    // This is the REAL euclidean rhythm algorithm used in music
    function bjorklund(steps, pulses, rotation = 0) {
      if (pulses >= steps) return Array(steps).fill(1);
      if (pulses <= 0) return Array(steps).fill(0);

      // Build pattern using Bjorklund's algorithm
      let pattern = [];
      let counts = [];
      let remainders = [];
      let divisor = steps - pulses;
      remainders.push(pulses);
      let level = 0;

      while (remainders[level] > 1) {
        counts.push(Math.floor(divisor / remainders[level]));
        remainders.push(divisor % remainders[level]);
        divisor = remainders[level];
        level++;
      }
      counts.push(divisor);

      function build(level) {
        if (level === -1) {
          pattern.push(0);
        } else if (level === -2) {
          pattern.push(1);
        } else {
          for (let i = 0; i < counts[level]; i++) build(level - 1);
          if (remainders[level] !== 0) build(level - 2);
        }
      }
      build(level);

      // Rotate pattern
      const rot = ((rotation % steps) + steps) % steps;
      return [...pattern.slice(rot), ...pattern.slice(0, rot)];
    }

    // Simple euclidean for quick generation
    const euclid = (steps, hits, offset = 0) => bjorklund(steps, hits, offset);

    // ============ PATTERN ALGORITHMS ============
    // Rotate pattern left or right
    function rotatePattern(arr, amount = 1) {
      const n = arr.length;
      const rot = ((amount % n) + n) % n;
      return [...arr.slice(rot), ...arr.slice(0, rot)];
    }

    // Reverse pattern
    function reversePattern(arr) {
      return [...arr].reverse();
    }

    // Invert pattern (on becomes off, off becomes on)
    function invertPattern(arr) {
      return arr.map(v => v ? 0 : 1);
    }

    // Cellular automata step (1D Rule 110 or similar)
    function cellularStep(arr, rule = 110) {
      const n = arr.length;
      const next = [];
      for (let i = 0; i < n; i++) {
        const left = arr[(i - 1 + n) % n] ? 1 : 0;
        const center = arr[i] ? 1 : 0;
        const right = arr[(i + 1) % n] ? 1 : 0;
        const idx = (left << 2) | (center << 1) | right;
        next[i] = (rule >> idx) & 1;
      }
      return next;
    }

    // Conway-style life for 16-step (neighbors wrap)
    function conwayStep(arr) {
      const n = arr.length;
      const next = [];
      for (let i = 0; i < n; i++) {
        const neighbors = (arr[(i - 1 + n) % n] ? 1 : 0) + (arr[(i + 1) % n] ? 1 : 0);
        const alive = arr[i] ? 1 : 0;
        // Birth: dead cell with exactly 1 neighbor becomes alive
        // Survival: alive cell with 1 neighbor survives
        // Death: otherwise
        next[i] = (alive && neighbors === 1) || (!alive && neighbors === 1) ? 1 : 0;
      }
      return next;
    }

    // Pattern mutator
    const mutate = (arr, chaos = 0.15) => arr.map((v, i, a) =>
      Math.random() < chaos ? (v ? 0 : a[Math.floor(Math.random() * a.length)]) : v
    );

    // ============ SCALES ============
    const SCALES = {
      PENTA:   { name: 'PENTA',   intervals: [0, 3, 5, 7, 10] },      // Minor pentatonic
      MAJOR:   { name: 'MAJOR',   intervals: [0, 2, 4, 5, 7, 9, 11] },
      MINOR:   { name: 'MINOR',   intervals: [0, 2, 3, 5, 7, 8, 10] },
      DORIAN:  { name: 'DORIAN',  intervals: [0, 2, 3, 5, 7, 9, 10] },
      PHRYG:   { name: 'PHRYG',   intervals: [0, 1, 3, 5, 7, 8, 10] },
      LYDIAN:  { name: 'LYDIAN',  intervals: [0, 2, 4, 6, 7, 9, 11] },
      MIXO:    { name: 'MIXO',    intervals: [0, 2, 4, 5, 7, 9, 10] },
      BLUES:   { name: 'BLUES',   intervals: [0, 3, 5, 6, 7, 10] },
      HARMMIN: { name: 'HARMMIN', intervals: [0, 2, 3, 5, 7, 8, 11] },
    };
    const SCALE_ORDER = ['PENTA', 'MAJOR', 'MINOR', 'DORIAN', 'PHRYG', 'LYDIAN', 'MIXO', 'BLUES', 'HARMMIN'];
    let currentScaleIdx = 0;
    let currentScale = SCALES.PENTA;

    const quantize = (midi, root = 48) => {
      const intervals = currentScale.intervals;
      const deg = Math.floor(Math.random() * intervals.length);
      const oct = Math.floor((midi - root) / 12);
      return root + intervals[deg] + oct * 12;
    };

    // Quantize to nearest scale note
    const quantizeNearest = (midi, root = 48) => {
      const intervals = currentScale.intervals;
      const note = midi % 12;
      const oct = Math.floor(midi / 12);
      let closest = intervals[0];
      let minDist = 12;
      for (const i of intervals) {
        const dist = Math.min(Math.abs(note - i), 12 - Math.abs(note - i));
        if (dist < minDist) {
          minDist = dist;
          closest = i;
        }
      }
      return oct * 12 + closest;
    };

    // ============ DRUMMIND GENRE ENGINE ============
    // ============ GENRE LIBRARY WITH MUSIC THEORY ============
    // Educational: Each genre has distinct rhythmic/harmonic characteristics
    // theory field explains what makes each genre unique musically

    // ============ CLASSIC MACHINE PACKS ============
    // Embedded pack definitions for standalone use
    // Full version at 1010packs.js

    function parsePackPattern(str) {
      const result = [];
      let i = 0;
      while (i < str.length && result.length < 16) {
        const char = str[i];
        if (char === 'x' || char === 'X') {
          result.push(char === 'X' ? 127 : 1);
          i++;
        } else if (char === '.') {
          result.push(0);
          i++;
        } else if (/[0-9A-Fa-f]/.test(char) && i + 1 < str.length) {
          const hex = str.substr(i, 2);
          result.push(parseInt(hex, 16));
          i += 2;
        } else {
          i++;
        }
      }
      while (result.length < 16) result.push(0);
      return result;
    }

    // KICK: 0x1050=decay, 0x1051=sweep, 0x1052=click, 0x1053=sub
    // SNARE: 0x1054=bodyDecay, 0x1055=noiseLevel, 0x1056=bodyTune, 0x1057=noiseBright
    const PACKS = {
      'TR-808': {
        name: 'Roland TR-808',
        year: 1980,
        init: () => [
          // SYNTH SELECT: $1058=1 selects kick808 (memory-mapped!)
          [0x1058, 1],
          // Snare: tonal body, moderate noise, lower brightness
          [0x1054, 120], [0x1055, 100], [0x1056, 80], [0x1057, 100],
          // Pattern params
          [0x1010, 32], [0x1030, 180], [0x1040, 120], [0x1310, 4],
          [0x1503, 0]
        ],
        patterns: {
          'Boom Bap': { bpm: 90, kick: 'x.....x...x.....', snare: '....x.......x...', noise: 'x.x.x.x.x.x.x.x.' }
        }
      },
      'TR-909': {
        name: 'Roland TR-909',
        year: 1983,
        init: () => [
          // SYNTH SELECT: $1058=2 selects kick909 (memory-mapped!)
          [0x1058, 2],
          // Snare: tight body, lots of noise, high brightness (the crack)
          [0x1054, 50], [0x1055, 200], [0x1056, 140], [0x1057, 220],
          // Pattern params
          [0x1010, 41], [0x1030, 200], [0x1040, 150], [0x1310, 6],
          [0x1503, 0]
        ],
        patterns: {
          'Four on the Floor': { bpm: 124, kick: 'x...x...x...x...', snare: '....x.......x...', noise: 'x.x.x.x.x.x.x.x.' }
        }
      },
      'TR-707': {
        name: 'Roland TR-707',
        year: 1984,
        init: () => [
          // Kick: digital, medium decay, moderate click
          [0x1050, 100], [0x1051, 120], [0x1052, 80], [0x1053, 90],
          // Snare: balanced, digital bright
          [0x1054, 70], [0x1055, 140], [0x1056, 120], [0x1057, 180],
          [0x1010, 38], [0x1030, 220], [0x1040, 100], [0x1310, 3],
          [0x1503, 0]
        ],
        patterns: {
          'New Wave': { bpm: 120, kick: 'x...x...x...x...', snare: '....x.......x...', noise: 'x.x.x.x.x.x.x.x.' }
        }
      },
      'CR-78': {
        name: 'Roland CR-78',
        year: 1978,
        init: () => [
          // Kick: vintage, softer, muted
          [0x1050, 80], [0x1051, 60], [0x1052, 0], [0x1053, 70],
          // Snare: papery, less noise
          [0x1054, 100], [0x1055, 60], [0x1056, 70], [0x1057, 80],
          [0x1010, 45], [0x1030, 160], [0x1040, 60], [0x1310, 2],
          [0x1503, 0]
        ],
        patterns: {
          'In The Air': { bpm: 94, kick: 'x.......x.......', snare: '....x.......x...', noise: 'x...x...x...x...' }
        }
      },
      'TB-303': {
        name: 'Roland TB-303',
        year: 1981,
        init: () => [
          [0x1220, 40], [0x1210, 80], [0x1230, 127]
        ],
        patterns: {
          'Acid Line': { bpm: 130, bass: '24..24..27..24..', kick: 'x...x...x...x...' }
        }
      },
      'JUNO-106': {
        name: 'Roland Juno-106',
        year: 1984,
        init: () => [
          [0x1110, 1], [0x1120, 90], [0x105E, 12], [0x1220, 70], [0x1210, 30]
        ],
        patterns: {
          'Synthwave': { bpm: 100, lead: '3C..3C..40..40..', bass: '30......30......' }
        }
      },
      'JP-8000': {
        name: 'Roland JP-8000',
        year: 1996,
        init: () => [
          [0x105E, 50], [0x1120, 127], [0x105F, 20], [0x1220, 90]
        ],
        patterns: {
          'Trance Lead': { bpm: 138, lead: '3C..3C..43..43..', bass: '30......30......' }
        }
      },
      'MS-20': {
        name: 'Korg MS-20',
        year: 1978,
        init: () => [
          [0x1220, 30], [0x1210, 100], [0x1230, 127], [0x105E, 5]
        ],
        patterns: {
          'Aggro Bass': { bpm: 125, bass: '24..2724..27....' }
        }
      },
      'M1': {
        name: 'Korg M1',
        year: 1988,
        init: () => [
          [0x1120, 85], [0x1220, 100], [0x1210, 10]
        ],
        patterns: {
          'House Organ': { bpm: 122, lead: '3C3C3C3C40404040', bass: '30......30......' }
        }
      },
      'Volca': {
        name: 'Korg Volca',
        year: 2013,
        init: () => [
          [0x1010, 36], [0x1030, 200], [0x1220, 60], [0x1210, 50]
        ],
        patterns: {
          'Pocket Techno': { bpm: 120, kick: 'x...x...x...x...', bass: '24..24..2724....' }
        }
      },
      'DX7': {
        name: 'Yamaha DX7',
        year: 1983,
        init: () => [
          [0x1210, 90], [0x1220, 80], [0x1230, 110], [0x1120, 95]
        ],
        patterns: {
          'FM Bass': { bpm: 116, bass: '24....24..27....' }
        }
      },
      'MPC60': {
        name: 'Akai MPC60',
        year: 1988,
        init: () => [
          // The magic 54% swing!
          [0x1503, 54],
          // Kick: warm sampler character, medium thump
          [0x1050, 150], [0x1051, 85], [0x1052, 30], [0x1053, 140],
          // Snare: classic sampled feel, balanced
          [0x1054, 90], [0x1055, 130], [0x1056, 100], [0x1057, 130],
          [0x1010, 38], [0x1030, 190], [0x1040, 130]
        ],
        patterns: {
          'Boom Bap Swing': { bpm: 94, kick: 'x.....x...x.....', snare: '....x.......x...', noise: 'x.x.x.x.x.x.x.x.' }
        }
      },
      'SP-1200': {
        name: 'E-mu SP-1200',
        year: 1987,
        init: () => [
          // Kick: lo-fi 12-bit crunch, punchy but gritty
          [0x1050, 120], [0x1051, 95], [0x1052, 50], [0x1053, 160],
          // Snare: crunchy, mid-heavy, that SP grit
          [0x1054, 80], [0x1055, 150], [0x1056, 90], [0x1057, 110],
          [0x1010, 36], [0x1030, 175], [0x1040, 140],
          [0x1503, 0]
        ],
        patterns: {
          'Golden Era': { bpm: 96, kick: 'x.....x...x.....', snare: '....x.......x.x.', noise: 'x.x.x.xxx.x.x.x.' }
        }
      },
      'Minimoog': {
        name: 'Moog Minimoog',
        year: 1970,
        init: () => [
          [0x1220, 50], [0x1210, 20], [0x1230, 127], [0x105F, 10]
        ],
        patterns: {
          'Moog Bass': { bpm: 110, bass: '24....24..24..27' }
        }
      },
      'Prophet-5': {
        name: 'Sequential Prophet-5',
        year: 1978,
        init: () => [
          [0x1220, 75], [0x1210, 35], [0x105E, 8], [0x1120, 100], [0x1230, 100]
        ],
        patterns: {
          'Poly Pad': { bpm: 90, lead: '3C..40..43..47..', bass: '30......30......' }
        }
      },
      'OB-X': {
        name: 'Oberheim OB-X',
        year: 1979,
        init: () => [
          [0x1220, 95], [0x1210, 40], [0x105E, 15], [0x1120, 127], [0x1230, 127]
        ],
        patterns: {
          'Jump': { bpm: 132, lead: '40..40..40..40..', bass: '34......30......' }
        }
      },
      'LinnDrum': {
        name: 'Linn LinnDrum',
        year: 1982,
        init: () => [
          // Kick: punchy digital sample character
          [0x1050, 100], [0x1051, 110], [0x1052, 60], [0x1053, 100],
          // Snare: the iconic 80s snare - tight, bright, cracking
          [0x1054, 60], [0x1055, 180], [0x1056, 130], [0x1057, 200],
          [0x1010, 40], [0x1030, 195], [0x1040, 90], [0x1310, 5],
          [0x1503, 0]
        ],
        patterns: {
          '80s Pop': { bpm: 118, kick: 'x...x...x...x...', snare: '....x.......x...', noise: 'x.x.x.x.x.x.x.x.' }
        }
      },
      'Fairlight': {
        name: 'Fairlight CMI',
        year: 1979,
        init: () => [
          [0x1220, 110], [0x1210, 15], [0x1120, 100]
        ],
        patterns: {
          'Orch Hit': { bpm: 120, lead: '48......48......' }
        }
      },
      'Techno': {
        name: 'Detroit Techno',
        year: 1988,
        init: () => [
          // Kick: hard, punchy 909-derived
          [0x1050, 80], [0x1051, 160], [0x1052, 150], [0x1053, 80],
          // Snare: tight, industrial
          [0x1054, 40], [0x1055, 190], [0x1056, 150], [0x1057, 200],
          [0x1010, 38], [0x1030, 190], [0x1040, 120], [0x1310, 5],
          [0x1503, 0]
        ],
        patterns: {
          'Minimal': { bpm: 130, kick: 'x...x...x...x...', snare: '........x.......', noise: '..x...x...x...x.' }
        }
      },
      'House': {
        name: 'Chicago House',
        year: 1984,
        init: () => [
          // Kick: deep 909 style with more sub
          [0x1050, 110], [0x1051, 140], [0x1052, 120], [0x1053, 120],
          // Snare: snappy, driving
          [0x1054, 55], [0x1055, 160], [0x1056, 125], [0x1057, 180],
          [0x1010, 40], [0x1030, 200], [0x1040, 130], [0x1310, 6],
          [0x1503, 15]
        ],
        patterns: {
          'Classic House': { bpm: 122, kick: 'x...x...x...x...', snare: '....x.......x...', noise: 'x.x.x.x.x.x.x.x.', bass: '24......2724....' }
        }
      },
      'DnB': {
        name: 'Drum & Bass',
        year: 1992,
        init: () => [
          // Kick: tight, punchy breakbeat style
          [0x1050, 70], [0x1051, 130], [0x1052, 90], [0x1053, 90],
          // Snare: tight, cracking break snare
          [0x1054, 45], [0x1055, 170], [0x1056, 140], [0x1057, 190],
          [0x1010, 42], [0x1030, 210], [0x1040, 150], [0x1310, 3],
          [0x1503, 0]
        ],
        patterns: {
          'Amen': { bpm: 170, kick: 'x.....x.x.......', snare: '....x..x....x..x', noise: 'x.x.x.x.x.x.x.x.' }
        }
      }
    };

    // Pack categories for faceted browser
    const PACK_CATS = {
      'TR-808': 'drums', 'TR-909': 'drums', 'TR-707': 'drums', 'CR-78': 'drums', 'LinnDrum': 'drums',
      'TB-303': 'synth', 'JUNO-106': 'synth', 'JP-8000': 'synth', 'MS-20': 'synth', 'M1': 'synth',
      'Volca': 'synth', 'DX7': 'synth', 'Minimoog': 'synth', 'Prophet-5': 'synth', 'OB-X': 'synth',
      'MPC60': 'sampler', 'SP-1200': 'sampler', 'Fairlight': 'sampler',
      'Techno': 'genre', 'House': 'genre', 'DnB': 'genre'
    };

    const DrumMind = {
      currentGenre: 0,
      genres: [
        // === HOUSE VARIANTS ===
        {
          name: 'HOUSE',
          tempoRange: [118, 130],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0],
          lead:  [60,0,0,60,0,0,67,0,0,0,63,0,0,0,0,0],
          theory: '4/4 time. Kick on 1,2,3,4. Offbeat hi-hats. 7th chords. Minor key.'
        },
        {
          name: 'DEEP HOUSE',
          tempoRange: [115, 125],
          swing: 15,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,0,0,0,0,0,0,36,0,0,0,0,0,0,36,0],
          lead:  [60,0,0,0,0,63,0,0,0,0,67,0,0,0,0,0],
          theory: '4/4 time. 9th/11th chord voicings. Minor 7th bass intervals. 15% swing.'
        },
        {
          name: 'TECH HOUSE',
          tempoRange: [124, 130],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,0,36,0,0,0,36,0,36,0,0,0,36,0,0,0],
          lead:  [60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: '4/4 time. Single-note basslines. Minimal melodic content. 0% swing.'
        },
        {
          name: 'ACID HOUSE',
          tempoRange: [120, 130],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,36,0,36,36,0,36,0,36,36,0,36,36,0,36,0],
          lead:  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: '4/4 time. Resonant filter sweeps on bass. 16th note patterns. 0% swing.'
        },
        {
          name: 'PROG HOUSE',
          tempoRange: [126, 132],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1],
          bass:  [36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          lead:  [60,0,0,0,0,0,0,0,63,0,0,0,0,0,67,0],
          theory: '4/4 time. 32-bar phrase structures. Layered arpeggios. Key modulation per section.'
        },
        // === TECHNO VARIANTS ===
        {
          name: 'TECHNO',
          tempoRange: [125, 145],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,36,0,0,36,0,0,36,36,0,0,0,36,0,36,0],
          lead:  [60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: '4/4 time. Phrygian/Locrian modes. Repetitive 8-bar phrases. 0% swing.'
        },
        {
          name: 'DETROIT',
          tempoRange: [125, 135],
          swing: 5,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,0,0,0,0,0,36,0,36,0,0,0,0,0,36,0],
          lead:  [60,0,0,63,0,0,67,0,0,0,72,0,0,0,0,0],
          theory: '4/4 time. Minor 7th chords. Suspended chord voicings. 5% swing.'
        },
        {
          name: 'BERLIN',
          tempoRange: [130, 140],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,0,36,0,36,0,36,0,36,0,36,0,36,0,36,0],
          lead:  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: '4/4 time. Minimal melodic content. 8th note bass. 0% swing.'
        },
        {
          name: 'ACID TECH',
          tempoRange: [135, 145],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1],
          bass:  [36,0,36,36,0,36,0,36,36,0,36,0,36,36,0,0],
          lead:  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: '4/4 time. Phrygian mode. Distorted bass. 16th note patterns. 0% swing.'
        },
        {
          name: 'HARD TECH',
          tempoRange: [145, 160],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
          noise: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
          bass:  [36,0,36,0,0,36,0,36,36,0,36,0,0,36,0,36],
          lead:  [48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: '4/4 time. Chromatic intervals. Distorted kick. 0% swing.'
        },
        // === TRANCE ===
        {
          name: 'TRANCE',
          tempoRange: [135, 150],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1],
          bass:  [36,0,36,0,36,0,36,0,36,0,36,0,36,0,36,0],
          lead:  [60,0,0,0,67,0,0,0,63,0,0,0,72,0,0,0],
          theory: '4/4 time. Major/minor key modulation. 32-bar phrases. Arpeggiated leads.'
        },
        {
          name: 'PSYTRANCE',
          tempoRange: [140, 150],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          noise: [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
          bass:  [36,0,36,36,0,36,0,36,36,0,36,0,36,36,0,36],
          lead:  [72,0,0,0,0,0,0,0,75,0,0,0,0,0,0,0],
          theory: '4/4 time. Phrygian dominant scale. Offbeat bass. Triplet subdivisions.'
        },
        {
          name: 'HARD TRANCE',
          tempoRange: [150, 160],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,36,0,36,36,0,36,36,36,0,36,36,36,0,36,36],
          lead:  [60,0,0,0,72,0,0,0,67,0,0,0,60,0,0,0],
          theory: '4/4 time. Harmonic minor scale. High-frequency leads. 16th note bass.'
        },
        // === BREAKBEAT STYLES ===
        {
          name: 'BREAK',
          tempoRange: [130, 150],
          swing: 20,
          kick:  [1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0],
          snare: [0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0],
          noise: [1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1],
          bass:  [36,0,0,0,0,0,36,0,0,0,0,0,36,0,0,0],
          lead:  [60,0,0,0,67,0,0,0,63,0,0,0,0,0,0,0],
          theory: '4/4 time. Syncopated kick. Ghost notes on snare. 20% swing.'
        },
        // === BASS MUSIC ===
        {
          name: 'DNB',
          tempoRange: [160, 180],
          swing: 0,
          kick:  [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
          snare: [0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0],
          noise: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
          bass:  [36,0,0,36,0,0,36,0,0,36,0,0,36,0,36,0],
          lead:  [60,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0],
          theory: '4/4 time. Half-time snare at 170+ BPM. Detuned saw bass. Syncopated kick.'
        },
        {
          name: 'DUBSTEP',
          tempoRange: [138, 142],
          swing: 0,
          kick:  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
          snare: [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],
          noise: [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
          bass:  [36,0,0,0,0,0,0,0,36,0,36,0,36,36,0,0],
          lead:  [60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: '4/4 time. Half-time at 140 BPM. LFO filter modulation. Minor key. Tritone intervals.'
        },
        // === UK SOUNDS ===
        {
          name: 'UK GARAGE',
          tempoRange: [130, 140],
          swing: 40,
          kick:  [1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0],
          snare: [0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,0,0,0,0,0,36,0,0,36,0,0,0,0,36,0],
          lead:  [67,0,0,63,0,0,60,0,0,0,67,0,0,63,0,0],
          theory: '4/4 time. 2-step pattern. Major 7th chords. 40% swing.'
        },
        {
          name: 'GRIME',
          tempoRange: [138, 142],
          swing: 15,
          kick:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
          noise: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
          bass:  [36,0,0,36,0,0,36,36,0,0,36,0,0,36,0,0],
          lead:  [60,0,0,0,0,63,0,0,60,0,0,0,0,0,0,0],
          theory: '4/4 time. Square wave leads. Minor/Phrygian mode. 15% swing.'
        },
        {
          name: 'BASSLINE',
          tempoRange: [135, 142],
          swing: 25,
          kick:  [1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,0,36,0,0,36,0,36,36,0,36,0,0,36,0,36],
          lead:  [60,0,0,63,0,0,67,0,0,0,60,0,0,0,0,0],
          theory: '4/4 time. Pitch-bent basslines. 2-step kick pattern. 25% swing.'
        },
        // === HIP-HOP/TRAP ===
        {
          name: 'HIP-HOP',
          tempoRange: [85, 95],
          swing: 45,
          kick:  [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
          bass:  [36,0,0,0,0,0,36,0,36,0,0,0,0,0,36,0],
          lead:  [0,0,60,0,0,0,0,0,0,0,63,0,0,0,0,0],
          theory: '4/4 boom bap. Kick on 1, before 2, 3, before 4. 8th note hats. 45% swing.'
        },
        // === ELECTRO/SYNTH ===
        {
          name: 'ELECTRO',
          tempoRange: [125, 135],
          swing: 10,
          kick:  [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1],
          noise: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
          bass:  [36,0,0,36,0,0,36,0,36,0,0,36,0,0,36,0],
          lead:  [60,0,0,0,63,0,0,0,67,0,0,0,63,0,0,0],
          theory: '4/4 time. Syncopated kick. Arpeggiated synths. 10% swing.'
        },
        {
          name: 'SYNTHWAVE',
          tempoRange: [80, 118],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          bass:  [36,0,36,0,0,0,36,0,36,0,36,0,0,0,36,0],
          lead:  [60,0,0,0,0,0,63,0,0,0,67,0,0,0,72,0],
          theory: '4/4 time. Arpeggiated synths. Major key/Dorian mode. Gated reverb. 0% swing.'
        },
        {
          name: 'DARKSYNTH',
          tempoRange: [100, 130],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,36,0,36,36,0,36,36,36,0,36,36,36,0,36,0],
          lead:  [48,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0],
          theory: '4/4 time. Distorted leads. Minor/Phrygian mode. 16th note bass. 0% swing.'
        },
        {
          name: 'EBM',
          tempoRange: [110, 130],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
          noise: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          bass:  [36,36,36,0,36,36,36,0,36,36,36,0,36,36,36,0],
          lead:  [60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: '4/4 time. Sequenced 16th note bass. Minimal melody. 0% swing.'
        },
        // === CHILL/AMBIENT ===
        {
          name: 'DOWNTEMPO',
          tempoRange: [70, 100],
          swing: 25,
          kick:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0],
          bass:  [36,0,0,0,0,0,0,0,0,0,0,0,36,0,0,0],
          lead:  [60,0,0,0,0,0,67,0,0,0,0,0,63,0,0,0],
          theory: '4/4 time. Extended chord voicings. Sparse density. 25% swing.'
        },
        {
          name: 'AMBIENT',
          tempoRange: [60, 80],
          swing: 0,
          kick:  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          snare: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          noise: [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          bass:  [36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          lead:  [60,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0],
          theory: 'No fixed meter. Open 5th intervals. Suspended chords. Pad textures.'
        },
        // === WORLD/LATIN ===
        {
          name: 'REGGAETON',
          tempoRange: [90, 100],
          swing: 10,
          kick:  [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0],
          snare: [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,0,0,0,0,0,36,0,36,0,0,0,0,0,36,0],
          lead:  [60,0,0,0,63,0,0,0,60,0,0,0,67,0,0,0],
          theory: '4/4 time. Dembow pattern (3-3-2 subdivision). Minor key. 10% swing.'
        },
        // === HALFTIME/HEAVY ===
        {
          name: 'HALFTIME',
          tempoRange: [70, 75],
          swing: 0,
          kick:  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          snare: [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
          noise: [0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0],
          bass:  [36,0,0,0,0,0,36,0,0,0,36,0,36,36,0,0],
          lead:  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: 'TRUE half-time at 70 BPM (not 140 feeling half). Snare on 3. Massive space. Sub bass focus.'
        },
        // === RETRO/8-BIT ===
        {
          name: 'CHIPTUNE',
          tempoRange: [120, 150],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
          bass:  [36,36,0,36,0,0,36,0,36,36,0,36,0,0,36,0],
          lead:  [60,0,60,0,63,0,63,0,67,0,67,0,72,0,67,0],
          theory: '8-bit style. Square/pulse waves. Arpeggiated leads. No swing. Limited voices = creative constraints.'
        },
        {
          name: 'ITALO',
          tempoRange: [115, 125],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
          bass:  [36,0,0,36,0,0,36,0,0,36,0,0,36,0,36,0],
          lead:  [60,63,67,72,67,63,60,0,60,63,67,72,67,63,60,0],
          theory: 'Italo Disco. Arpeggiated synths. Four-on-floor. Melodic bass runs. 80s production.'
        },
        {
          name: 'NEW WAVE',
          tempoRange: [110, 130],
          swing: 5,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
          noise: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
          bass:  [36,0,0,0,0,0,36,0,0,0,36,0,0,0,0,0],
          lead:  [60,0,0,63,0,0,67,0,0,0,63,0,0,0,0,0],
          theory: '80s synth pop. Gated reverb snare. Synth pads. Minor keys. Light swing.'
        },
        // === HARD/FAST ===
        {
          name: 'GABBER',
          tempoRange: [160, 190],
          swing: 0,
          kick:  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          bass:  [36,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0],
          lead:  [48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: 'Rotterdam hardcore. Distorted kick on every beat. 160+ BPM. Minimal melody. Pure aggression.'
        },
        {
          name: 'HARDSTYL',
          tempoRange: [150, 155],
          swing: 0,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
          bass:  [36,0,36,36,0,0,36,36,36,0,36,36,0,0,36,36],
          lead:  [60,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0],
          theory: 'Hardstyle. Reverse bass technique. Hard kick. Euphoric leads. 150 BPM.'
        },
        // === MINIMAL/EXPERIMENTAL ===
        {
          name: 'MINIMAL',
          tempoRange: [125, 132],
          swing: 5,
          kick:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          snare: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          noise: [0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0],
          bass:  [36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          lead:  [60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          theory: 'Less is more. Stripped down techno. Subtle variations. Hypnotic repetition. Teaches restraint.'
        },
        {
          name: 'INDUST',
          tempoRange: [120, 140],
          swing: 0,
          kick:  [1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0],
          snare: [0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
          noise: [1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0],
          bass:  [36,0,36,0,0,0,36,0,36,0,36,0,0,0,36,0],
          lead:  [48,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0],
          theory: 'Industrial. Distorted everything. Mechanical rhythms. Harsh frequencies. Noise as instrument.'
        },
        {
          name: 'MIAMI',
          tempoRange: [125, 135],
          swing: 15,
          kick:  [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          noise: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
          bass:  [36,0,0,36,0,0,36,0,36,0,0,36,0,0,36,0],
          lead:  [60,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0],
          theory: 'Miami Bass / Booty. 808 heavy. Syncopated kick. Call-response bass. 15% swing.'
        },
      ],

      applyGenre(idx) {
        const g = this.genres[idx];
        this.currentGenre = idx;

        // Apply patterns - mark all memory writes as hot
        for (let i = 0; i < 16; i++) {
          MEM[0x1000 + i] = g.kick[i];
          MEM[0x1010 + i] = g.kick[i] ? 36 : 0;
          MEM[0x1020 + i] = g.snare[i];
          MEM[0x1030 + i] = g.snare[i] ? 180 : 0;
          MEM[0x1040 + i] = g.snare[i] ? 100 : 0;
          MEM[0x1100 + i] = g.lead[i];
          MEM[0x1110 + i] = 0;
          MEM[0x1200 + i] = g.bass[i];
          MEM[0x1210 + i] = g.bass[i] ? 40 : 0;
          MEM[0x1220 + i] = g.bass[i] ? 70 : 0;
          MEM[0x1300 + i] = g.noise[i];
          MEM[0x1310 + i] = g.noise[i] ? 14 : 0;
          MEM[0x1320 + i] = 0;
        }
        // Mark all written regions as hot for heat visualization
        markHotRange(0x1000, 16); // kick gate
        markHotRange(0x1010, 16); // kick param
        markHotRange(0x1020, 16); // snare gate
        markHotRange(0x1030, 16); // snare decay
        markHotRange(0x1040, 16); // snare tone
        markHotRange(0x1100, 16); // lead
        markHotRange(0x1110, 16); // lead param
        markHotRange(0x1200, 16); // bass
        markHotRange(0x1210, 16); // bass filter
        markHotRange(0x1220, 16); // bass reso
        markHotRange(0x1300, 16); // noise
        markHotRange(0x1310, 16); // noise param
        markHotRange(0x1320, 16); // noise param2

        // Apply swing to memory AND UI variable
        swing = g.swing;
        MEM[0x1503] = swing;
        document.getElementById('swing-display').innerText = 'SW ' + swing + '%';

        // Suggest tempo - write to memory AND UI
        const suggestedTempo = Math.floor((g.tempoRange[0] + g.tempoRange[1]) / 2);
        tempo = suggestedTempo;
        MEM[0x1501] = tempo;
        document.getElementById('tempo-display').innerText = tempo;

        saveToScene(currentScene);
        syncGridsFromMem();
        syncSlidersFromMem();
        updateMemDisplay();
        baseGenre = g.name; // Track for persistence
        document.getElementById('genre-display').innerText = g.name;
        document.getElementById('status').innerText = `GENRE: ${g.name} (${g.tempoRange[0]}-${g.tempoRange[1]} BPM)`;

        // Show theory tooltip
        if (g.theory) {
          showTheory(g.name, g.theory);
        }

        TIMELINE.record('genre', { genre: g.name });
      },

      nextGenre() {
        const idx = (this.currentGenre + 1) % this.genres.length;
        this.applyGenre(idx);
      },

      // Humanize: add slight variations
      // level: 1=lite (5% chance, ±3), 2=full (10% chance, ±5)
      humanize(level = 2) {
        const chance = level === 1 ? 0.05 : 0.10;
        const range = level === 1 ? 3 : 5;

        Object.keys(VOICES).forEach(voice => {
          const v = VOICES[voice];
          for (let i = 0; i < 16; i++) {
            if (MEM[v.gate + i] && Math.random() < chance) {
              // Slight velocity/param variation
              v.params.forEach(p => {
                const current = MEM[p.addr + i];
                if (current > 0) {
                  MEM[p.addr + i] = Math.max(1, Math.min(127, current + Math.floor(Math.random() * range * 2) - range));
                }
              });
            }
          }
        });
      }
    };

    // ============ AUTO-EVOLVE MODE ============
    let evolveActive = true;  // On by default
    let evolveTimer = null;
    let evolveCounter = 0;

    // ============ EVOLVE DSL CONFIG ============
    const EVOLVE = {
      // Per-voice: enabled, amount (0-100), mutation types
      // Drums: conservative. Melodic: more variation.
      voices: {
        kick:  { on: true, amt: 5,  shift: false, addRm: false, oct: true, rev: false, prob: false, ratch: false, swap: false },
        snare: { on: true, amt: 10, shift: false, addRm: false, oct: true, rev: false, prob: false, ratch: false, swap: false },
        lead:  { on: true, amt: 85, shift: true, addRm: true, oct: true, rev: true, prob: false, ratch: false, swap: false },
        bass:  { on: true, amt: 70, shift: true, addRm: true, oct: true, rev: false, prob: false, ratch: false, swap: false },
        noise: { on: true, amt: 35, shift: true, addRm: true, oct: false, rev: true, prob: true, ratch: true, swap: true }
      },
      interval: 8,        // Steps between mutations (8 = half bar)
      humanize: 2,        // Humanization: 0=off, 1=lite, 2=full
      humanizeInt: 64,    // Humanize interval
      // Global settings
      density: 0,         // -50 (remove bias) to +50 (add bias)
      chaos: 3,           // 1-10: mutation intensity
      lockRoot: false,    // Protect melodic root notes
      chainScenes: false, // Auto-switch scenes
      chainInterval: 128, // Steps between scene switches

      activeVoices() {
        return Object.keys(this.voices).filter(v => this.voices[v].on);
      }
    };

    // ============ TIMELINE RECORDER ============
    // Educational: This is like a "git log" for your music session!
    // Every change gets recorded with a timestamp (bar:beat)
    // The output is a human-readable DSL you can edit and replay

    let currentBar = 0;           // Tracks which bar we're on (increments every 16 steps)
    let totalSteps = 0;           // Total steps since play started
    let timelineRecording = true; // Toggle recording on/off

    const TIMELINE = {
      title: 'Untitled Session',
      events: [],                 // Array of {bar, beat, type, data}
      snapshots: {},              // Pattern snapshots at key moments: {bar: memSnapshot}
      undoStack: [],              // Stack of previous states for undo
      redoStack: [],              // Stack of undone states for redo
      maxHistory: 50,             // Max undo levels

      // Save current state to undo stack
      pushUndo() {
        this.undoStack.push({
          events: JSON.parse(JSON.stringify(this.events)),
          snapshots: JSON.parse(JSON.stringify(this.snapshots)),
          mem: Array.from(MEM.slice(0x1000, 0x1400))
        });
        if (this.undoStack.length > this.maxHistory) {
          this.undoStack.shift();
        }
        this.redoStack = []; // Clear redo on new action
        this.updateUndoButtons();
      },

      undo() {
        if (this.undoStack.length === 0) return;
        // Save current to redo
        this.redoStack.push({
          events: JSON.parse(JSON.stringify(this.events)),
          snapshots: JSON.parse(JSON.stringify(this.snapshots)),
          mem: Array.from(MEM.slice(0x1000, 0x1400))
        });
        // Restore from undo
        const state = this.undoStack.pop();
        this.events = state.events;
        this.snapshots = state.snapshots;
        for (let i = 0; i < state.mem.length; i++) {
          MEM[0x1000 + i] = state.mem[i];
        }
        syncGridsFromMem();
        updateMemDisplay();
        this.updateDisplay();
        this.updateUndoButtons();
        document.getElementById('status').innerText = 'UNDO';
      },

      redo() {
        if (this.redoStack.length === 0) return;
        // Save current to undo
        this.undoStack.push({
          events: JSON.parse(JSON.stringify(this.events)),
          snapshots: JSON.parse(JSON.stringify(this.snapshots)),
          mem: Array.from(MEM.slice(0x1000, 0x1400))
        });
        // Restore from redo
        const state = this.redoStack.pop();
        this.events = state.events;
        this.snapshots = state.snapshots;
        for (let i = 0; i < state.mem.length; i++) {
          MEM[0x1000 + i] = state.mem[i];
        }
        syncGridsFromMem();
        updateMemDisplay();
        this.updateDisplay();
        this.updateUndoButtons();
        document.getElementById('status').innerText = 'REDO';
      },

      updateUndoButtons() {
        document.getElementById('tl-undo').disabled = this.undoStack.length === 0;
        document.getElementById('tl-redo').disabled = this.redoStack.length === 0;
      },

      // Record an event to the timeline
      record(type, data) {
        if (!timelineRecording || !isPlaying) return;
        this.pushUndo(); // Save state before recording
        const beat = step % 4;      // 0-3 within quarter note
        const event = { bar: currentBar, beat, step: step, type, data, ts: Date.now() };
        this.events.push(event);
        this.updateDisplay();
        console.log(`[TIMELINE] Bar ${currentBar}:${beat} → ${type}`, data);
      },

      // Take a snapshot of current pattern state
      snapshot(label = '') {
        const mem = new Uint8Array(MEM.slice(0x1000, 0x1400));
        this.snapshots[currentBar] = {
          label,
          mem: Array.from(mem),
          scene: currentScene,
          tempo, swing,
          scale: currentScale.name,
          evolve: evolveActive
        };
        this.record('snapshot', { label: label || `Bar ${currentBar}` });
      },

      // Clear the timeline
      clear() {
        this.events = [];
        this.snapshots = {};
        currentBar = 0;
        totalSteps = 0;
        this.updateDisplay();
      },

      // Format timeline as DSL text
      // Convert 16-step gate array to pattern string: x = hit, . = rest
      memToPattern(addr) {
        let p = '';
        for (let i = 0; i < 16; i++) {
          p += MEM[addr + i] ? 'x' : '.';
        }
        return p;
      },

      // Convert 16-step note array to pattern with note names
      memToMelody(gateAddr, noteAddr) {
        let p = '';
        for (let i = 0; i < 16; i++) {
          if (MEM[gateAddr + i]) {
            const note = MEM[noteAddr + i] || MEM[gateAddr + i];
            const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
            const oct = Math.floor(note / 12) - 1;
            const name = names[note % 12];
            p += name + oct + ' ';
          } else {
            p += '... ';
          }
        }
        return p.trim();
      },

      // Compare two snapshots and return diff summary
      diffSnapshots(bar1, bar2) {
        const snap1 = this.snapshots[bar1];
        const snap2 = this.snapshots[bar2];
        if (!snap1 || !snap2) return null;

        const voices = [
          { name: 'kick', addr: 0, len: 16 },
          { name: 'snare', addr: 0x20, len: 16 },
          { name: 'lead', addr: 0x100, len: 16 },
          { name: 'bass', addr: 0x200, len: 16 },
          { name: 'noise', addr: 0x300, len: 16 }
        ];

        const changes = [];
        voices.forEach(v => {
          let added = 0, removed = 0, modified = 0;
          for (let i = 0; i < v.len; i++) {
            const a = snap1.mem[v.addr + i];
            const b = snap2.mem[v.addr + i];
            if (a && !b) removed++;
            else if (!a && b) added++;
            else if (a !== b) modified++;
          }
          if (added || removed || modified) {
            changes.push(`${v.name}:+${added}/-${removed}/~${modified}`);
          }
        });

        return changes.length > 0 ? changes.join(' ') : 'no changes';
      },

      // Get pattern diff as visual string (show what changed with markers)
      patternDiff(snap1, snap2, addr) {
        if (!snap1 || !snap2) return '';
        let diff = '';
        for (let i = 0; i < 16; i++) {
          const a = snap1.mem[addr + i];
          const b = snap2.mem[addr + i];
          if (a && !b) diff += '-';      // removed
          else if (!a && b) diff += '+';  // added
          else if (a !== b) diff += '~';  // modified
          else if (b) diff += 'x';        // unchanged hit
          else diff += '.';               // unchanged rest
        }
        return diff;
      },

      // Generate DSL with full pattern notation
      toDSL() {
        let dsl = `$1010 SONG v1\n`;
        dsl += `@title "${this.title}"\n`;
        dsl += `@tempo ${tempo}\n`;
        dsl += `@scale ${currentScale.name}\n`;
        dsl += `@swing ${swing}\n\n`;

        // Group events by bar
        const byBar = {};
        this.events.forEach(e => {
          if (!byBar[e.bar]) byBar[e.bar] = [];
          byBar[e.bar].push(e);
        });

        // Output each bar's events
        const sortedBars = Object.keys(this.snapshots).map(Number).sort((a,b) => a - b);
        Object.keys(byBar).sort((a,b) => a - b).forEach(bar => {
          dsl += `[${bar}] `;
          const evts = byBar[bar];
          evts.forEach((e, i) => {
            if (e.type === 'scene') dsl += `scene:${String.fromCharCode(65 + e.data.scene)} `;
            else if (e.type === 'tempo') dsl += `tempo:${e.data.tempo} `;
            else if (e.type === 'swing') dsl += `swing:${e.data.swing}% `;
            else if (e.type === 'evolve') dsl += `evolve:${e.data.on ? 'on' : 'off'} `;
            else if (e.type === 'scale') dsl += `scale:${e.data.scale} `;
            else if (e.type === 'genre') dsl += `genre:${e.data.genre} `;
            else if (e.type === 'mutation') dsl += `+${e.data.voice}:${e.data.mutation} `;
            else if (e.type === 'snapshot') dsl += `# ${e.data.label} `;
          });
          dsl += `\n`;

          // If there's a snapshot, output pattern state with notation
          if (this.snapshots[bar]) {
            const snap = this.snapshots[bar];
            // Temporarily load snapshot to read patterns
            const oldMem = MEM.slice(0x1000, 0x1400);
            for (let i = 0; i < snap.mem.length; i++) MEM[0x1000 + i] = snap.mem[i];

            // Find previous snapshot for diff
            const prevBar = sortedBars.filter(b => b < parseInt(bar)).pop();
            const prevSnap = prevBar !== undefined ? this.snapshots[prevBar] : null;

            if (prevSnap) {
              // Show diff: + added, - removed, ~ modified
              dsl += `    # diff from bar ${prevBar}: ${this.diffSnapshots(prevBar, bar)}\n`;
              dsl += `    kick:  ${this.patternDiff(prevSnap, snap, 0)}\n`;
              dsl += `    snare: ${this.patternDiff(prevSnap, snap, 0x20)}\n`;
              dsl += `    lead:  ${this.patternDiff(prevSnap, snap, 0x100)}\n`;
              dsl += `    bass:  ${this.patternDiff(prevSnap, snap, 0x200)}\n`;
              dsl += `    noise: ${this.patternDiff(prevSnap, snap, 0x300)}\n`;
            } else {
              // First snapshot - show full pattern
              dsl += `    kick:  ${this.memToPattern(0x1000)}\n`;
              dsl += `    snare: ${this.memToPattern(0x1020)}\n`;
              dsl += `    lead:  ${this.memToMelody(0x1100, 0x1100)}\n`;
              dsl += `    bass:  ${this.memToMelody(0x1200, 0x1200)}\n`;
              dsl += `    noise: ${this.memToPattern(0x1300)}\n`;
            }

            // Restore memory
            for (let i = 0; i < oldMem.length; i++) MEM[0x1000 + i] = oldMem[i];
          }
        });

        dsl += `\n[${currentBar}] end  # Total: ${currentBar} bars\n`;
        return dsl;
      },

      // Parse DSL text and return structured data
      // Educational: This is a simple recursive descent parser!
      // Pre-process DSL: expand macros and loops
      // Educational: This is like a preprocessor in C!
      preprocessDSL(text) {
        let processed = text;
        const macros = {};

        // Extract @define blocks: @define NAME { ... }
        const defineRegex = /@define\s+(\w+)\s*\{([^}]+)\}/g;
        let match;
        while ((match = defineRegex.exec(text)) !== null) {
          macros[match[1]] = match[2].trim();
          processed = processed.replace(match[0], '');
        }

        // Replace @use NAME with macro content
        Object.keys(macros).forEach(name => {
          const useRegex = new RegExp(`@use\\s+${name}\\b`, 'g');
          processed = processed.replace(useRegex, macros[name]);
        });

        // Expand @repeat N { ... } blocks
        const repeatRegex = /@repeat\s+(\d+)\s*\{([^}]+)\}/g;
        while ((match = repeatRegex.exec(processed)) !== null) {
          const count = parseInt(match[1]);
          const content = match[2].trim();
          const expanded = Array(count).fill(content).join('\n');
          processed = processed.replace(match[0], expanded);
          repeatRegex.lastIndex = 0; // Reset for nested repeats
        }

        // Expand @bars N:M { ... } - apply pattern to bar range
        const barsRegex = /@bars\s+(\d+):(\d+)\s*\{([^}]+)\}/g;
        while ((match = barsRegex.exec(processed)) !== null) {
          const start = parseInt(match[1]);
          const end = parseInt(match[2]);
          const content = match[3].trim();
          let expanded = '';
          for (let b = start; b <= end; b++) {
            expanded += `[${b}] ${content}\n`;
          }
          processed = processed.replace(match[0], expanded);
          barsRegex.lastIndex = 0;
        }

        return processed;
      },

      fromDSL(text) {
        // Pre-process macros first
        const processed = this.preprocessDSL(text);

        const result = {
          title: 'Untitled',
          tempo: 100,
          scale: 'MINOR',
          swing: 0,
          bars: []  // Array of {bar, events, patterns}
        };

        const lines = processed.split('\n');
        let currentBarData = null;

        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith('#')) continue;

          // Parse header directives @key value
          if (trimmed.startsWith('@')) {
            const match = trimmed.match(/@(\w+)\s+(.+)/);
            if (match) {
              const [, key, val] = match;
              if (key === 'title') result.title = val.replace(/"/g, '');
              else if (key === 'tempo') result.tempo = parseInt(val);
              else if (key === 'scale') result.scale = val;
              else if (key === 'swing') result.swing = parseInt(val);
            }
            continue;
          }

          // Parse bar marker [N] events...
          const barMatch = trimmed.match(/^\[(\d+)\]\s*(.*)/);
          if (barMatch) {
            const [, barNum, eventStr] = barMatch;
            if (eventStr.includes('end')) continue;

            currentBarData = { bar: parseInt(barNum), events: [], patterns: {} };
            result.bars.push(currentBarData);

            // Parse events on this line
            const eventParts = eventStr.split(/\s+/);
            for (const part of eventParts) {
              if (part.startsWith('scene:')) {
                currentBarData.events.push({ type: 'scene', scene: part.slice(6).charCodeAt(0) - 65 });
              } else if (part.startsWith('tempo:')) {
                currentBarData.events.push({ type: 'tempo', tempo: parseInt(part.slice(6)) });
              } else if (part.startsWith('swing:')) {
                currentBarData.events.push({ type: 'swing', swing: parseInt(part.slice(6)) });
              } else if (part.startsWith('evolve:')) {
                currentBarData.events.push({ type: 'evolve', on: part.slice(7) === 'on' });
              } else if (part.startsWith('scale:')) {
                currentBarData.events.push({ type: 'scale', scale: part.slice(6) });
              } else if (part.startsWith('genre:')) {
                currentBarData.events.push({ type: 'genre', genre: part.slice(6) });
              }
            }
            continue;
          }

          // Parse pattern lines (indented): voice: pattern
          const patternMatch = trimmed.match(/^(\w+):\s+(.+)/);
          if (patternMatch && currentBarData) {
            const [, voice, pattern] = patternMatch;
            currentBarData.patterns[voice] = pattern;
          }
        }

        return result;
      },

      // Load parsed DSL and apply to sequencer
      loadDSL(text) {
        const data = this.fromDSL(text);

        // Apply header settings
        this.title = data.title;
        tempo = data.tempo;
        document.getElementById('tempo-display').innerText = tempo;
        swing = data.swing;
        document.getElementById('swing-display').innerText = 'SW ' + swing + '%';

        if (SCALES[data.scale]) {
          currentScale = SCALES[data.scale];
          document.getElementById('scale-display').innerText = data.scale;
        }

        // Clear and rebuild timeline
        this.clear();

        // Create snapshots from bar data
        data.bars.forEach(barData => {
          // Store events
          barData.events.forEach(evt => {
            this.events.push({ bar: barData.bar, beat: 0, step: 0, type: evt.type, data: evt, ts: Date.now() });
          });

          // If patterns exist, create snapshot
          if (Object.keys(barData.patterns).length > 0) {
            const mem = new Array(1024).fill(0);

            // Parse drum patterns (x = hit, . = rest)
            ['kick', 'snare', 'noise'].forEach(voice => {
              if (barData.patterns[voice]) {
                const addr = voice === 'kick' ? 0 : voice === 'snare' ? 0x20 : 0x300;
                const pattern = barData.patterns[voice];
                for (let i = 0; i < 16 && i < pattern.length; i++) {
                  mem[addr + i] = pattern[i] === 'x' ? 1 : 0;
                }
              }
            });

            // Parse melodic patterns (note names)
            ['lead', 'bass'].forEach(voice => {
              if (barData.patterns[voice]) {
                const addr = voice === 'lead' ? 0x100 : 0x200;
                const notes = barData.patterns[voice].split(/\s+/);
                for (let i = 0; i < 16 && i < notes.length; i++) {
                  if (notes[i] !== '...') {
                    const noteMatch = notes[i].match(/([A-G]#?)(\d)/);
                    if (noteMatch) {
                      const [, name, oct] = noteMatch;
                      const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
                      const noteNum = names.indexOf(name) + (parseInt(oct) + 1) * 12;
                      mem[addr + i] = noteNum;
                    }
                  }
                }
              }
            });

            this.snapshots[barData.bar] = {
              label: `Bar ${barData.bar}`,
              mem: mem,
              scene: 0,
              tempo: data.tempo,
              swing: data.swing,
              scale: data.scale,
              evolve: false
            };
          }
        });

        // Apply first snapshot if exists
        const firstBar = Object.keys(this.snapshots).sort((a,b) => a - b)[0];
        if (firstBar !== undefined) {
          this.scrubTo(parseInt(firstBar));
        }

        this.updateDisplay();
        document.getElementById('status').innerText = `LOADED: ${data.title}`;
        return data;
      },

      // Scrub to a specific bar (restore snapshot state)
      scrubTo(bar) {
        // Find nearest snapshot at or before this bar
        const snapBars = Object.keys(this.snapshots).map(Number).sort((a,b) => a - b);
        let targetBar = snapBars[0];
        for (const b of snapBars) {
          if (b <= bar) targetBar = b;
          else break;
        }

        if (this.snapshots[targetBar]) {
          const snap = this.snapshots[targetBar];

          // Restore memory
          for (let i = 0; i < snap.mem.length; i++) {
            MEM[0x1000 + i] = snap.mem[i];
          }

          // Restore settings
          tempo = snap.tempo;
          document.getElementById('tempo-display').innerText = tempo;
          swing = snap.swing;
          document.getElementById('swing-display').innerText = 'SW ' + swing + '%';

          if (SCALES[snap.scale]) {
            currentScale = SCALES[snap.scale];
            document.getElementById('scale-display').innerText = snap.scale;
          }

          // Apply events between snapshot and target bar
          this.events
            .filter(e => e.bar >= targetBar && e.bar <= bar)
            .forEach(e => {
              if (e.type === 'tempo') tempo = e.data.tempo;
              else if (e.type === 'swing') swing = e.data.swing;
              else if (e.type === 'scene') switchScene(e.data.scene);
              else if (e.type === 'evolve') evolveActive = e.data.on;
            });

          currentBar = bar;
          syncGridsFromMem();
          updateMemDisplay();
          this.updateDisplay();
          document.getElementById('status').innerText = `SCRUB: BAR ${bar}`;
        }
      },

      // Update the timeline display panel
      updateDisplay() {
        const panel = document.getElementById('timeline-output');
        if (panel) {
          panel.value = this.toDSL();
        }
        const barDisplay = document.getElementById('bar-display');
        if (barDisplay) {
          barDisplay.textContent = `BAR ${currentBar}`;
        }
        // Update scrubber range
        const scrubber = document.getElementById('tl-scrubber');
        if (scrubber && Object.keys(this.snapshots).length > 0) {
          const maxBar = Math.max(currentBar, ...Object.keys(this.snapshots).map(Number));
          scrubber.max = maxBar;
          scrubber.value = currentBar;
          scrubber.disabled = false;
          document.querySelector('.scrub-label').textContent = `BAR ${currentBar}/${maxBar}`;
        }
      }
    };

    function toggleEvolve() {
      evolveActive = !evolveActive;
      const btn = document.getElementById('btn-evolve');
      const panel = document.getElementById('evolve-panel');

      if (evolveActive) {
        btn.classList.add('evolve-active');
        evolveCounter = 0;
        if (panel) panel.classList.add('open');
        document.getElementById('status').innerText = 'EVOLVE: ON';
      } else {
        btn.classList.remove('evolve-active');
        if (panel) panel.classList.remove('open');
        document.getElementById('status').innerText = 'EVOLVE: OFF';
      }
      TIMELINE.record('evolve', { on: evolveActive });
    }

    function evolveStep() {
      if (!evolveActive || !isPlaying) return;

      evolveCounter++;

      // Scene chaining
      if (EVOLVE.chainScenes && evolveCounter % EVOLVE.chainInterval === 0) {
        const nextScene = (currentScene + 1) % 4;
        switchScene(nextScene);
        document.getElementById('status').innerText = `EVO: CHAIN → ${String.fromCharCode(65 + nextScene)}`;
      }

      if (evolveCounter % EVOLVE.interval === 0) {
        // Chaos affects how many mutations per interval
        const mutations = Math.ceil(EVOLVE.chaos / 3);

        for (let m = 0; m < mutations; m++) {
          const active = EVOLVE.activeVoices();
          if (active.length === 0) return;

          const voiceName = active[Math.floor(Math.random() * active.length)];
          const cfg = EVOLVE.voices[voiceName];
          const v = VOICES[voiceName];

          // Check amount threshold (chaos increases likelihood)
          const threshold = cfg.amt + (EVOLVE.chaos * 2);
          if (Math.random() * 100 > threshold) continue;

          // Build mutation options
          const opts = [];
          if (cfg.shift) opts.push('shift');
          if (cfg.addRm) opts.push('addRm');
          if (cfg.oct && v.isNote) opts.push('oct');
          if (cfg.rev) opts.push('rev');
          if (cfg.prob) opts.push('prob');
          if (cfg.ratch) opts.push('ratch');
          if (cfg.swap) opts.push('swap');
          if (opts.length === 0) continue;

          const mutation = opts[Math.floor(Math.random() * opts.length)];

          if (mutation === 'shift') {
            // Chaos affects shift amount
            const shiftAmt = Math.ceil(Math.random() * Math.ceil(EVOLVE.chaos / 3));
            const dir = Math.random() < 0.5 ? shiftAmt : -shiftAmt;
            const temp = [];
            for (let i = 0; i < 16; i++) temp[i] = MEM[v.gate + i];
            for (let i = 0; i < 16; i++) MEM[v.gate + i] = temp[(i - dir + 16) % 16];
          } else if (mutation === 'addRm') {
            const step = Math.floor(Math.random() * 16);
            const hasNote = MEM[v.gate + step];

            // Density biases add vs remove: +50 = always add, -50 = always remove
            const addBias = (EVOLVE.density + 50) / 100; // 0 to 1
            const shouldAdd = hasNote ? (Math.random() > addBias) : (Math.random() < addBias);

            if (hasNote && !shouldAdd) {
              // Lock root: don't remove if it's the first note of a melodic voice
              if (EVOLVE.lockRoot && v.isNote && step === 0) continue;
              MEM[v.gate + step] = 0;
            } else if (!hasNote && shouldAdd) {
              MEM[v.gate + step] = v.isNote ? quantize(v === VOICES.bass ? 36 : 60) : 1;
              v.params.forEach(p => MEM[p.addr + step] = p.def);
            }
          } else if (mutation === 'oct') {
            // Chaos affects how many notes change
            const changeChance = 0.1 + (EVOLVE.chaos * 0.05);
            for (let i = 0; i < 16; i++) {
              // Lock root: skip first step
              if (EVOLVE.lockRoot && i === 0) continue;
              if (MEM[v.gate + i] && Math.random() < changeChance) {
                const newNote = quantizeNearest(MEM[v.gate + i] + (Math.random() < 0.5 ? 12 : -12));
                MEM[v.gate + i] = Math.max(24, Math.min(84, newNote));
              }
            }
          } else if (mutation === 'rev') {
            // Reverse pattern (or partial reverse based on chaos)
            const temp = [];
            for (let i = 0; i < 16; i++) temp[i] = MEM[v.gate + i];
            const start = EVOLVE.lockRoot ? 1 : 0;
            const len = 16 - start;
            for (let i = start; i < 16; i++) {
              MEM[v.gate + i] = temp[start + (len - 1 - (i - start))];
            }
          } else if (mutation === 'prob') {
            // Mutate probability/velocity (params[0] is typically velocity-like)
            if (v.params && v.params.length > 0) {
              const pAddr = v.params[0].addr;
              const pMax = v.params[0].max || 127;
              for (let i = 0; i < 16; i++) {
                if (MEM[v.gate + i] && Math.random() < 0.3) {
                  const delta = Math.floor((Math.random() - 0.5) * pMax * 0.3);
                  MEM[pAddr + i] = Math.max(0, Math.min(pMax, MEM[pAddr + i] + delta));
                }
              }
            }
          } else if (mutation === 'ratch') {
            // Ratchet: double up a step by copying to next empty slot
            const active = [];
            for (let i = 0; i < 16; i++) if (MEM[v.gate + i]) active.push(i);
            if (active.length > 0) {
              const src = active[Math.floor(Math.random() * active.length)];
              const dst = (src + 1) % 16;
              if (!MEM[v.gate + dst] && !(EVOLVE.lockRoot && dst === 0)) {
                MEM[v.gate + dst] = MEM[v.gate + src];
                v.params.forEach(p => MEM[p.addr + dst] = MEM[p.addr + src]);
              }
            }
          } else if (mutation === 'swap') {
            // Swap steps with another active voice
            const otherVoices = EVOLVE.activeVoices().filter(n => n !== voiceName && EVOLVE.voices[n].swap);
            if (otherVoices.length > 0) {
              const otherName = otherVoices[Math.floor(Math.random() * otherVoices.length)];
              const other = VOICES[otherName];
              const step = Math.floor(Math.random() * 16);
              if (!(EVOLVE.lockRoot && step === 0)) {
                const tmp = MEM[v.gate + step];
                MEM[v.gate + step] = MEM[other.gate + step] ? 1 : 0;
                MEM[other.gate + step] = tmp ? 1 : 0;
              }
            }
          }

          document.getElementById('status').innerText = `EVO: ${voiceName.toUpperCase()} ${mutation}`;
          TIMELINE.record('mutation', { voice: voiceName, mutation });
        }

        saveToScene(currentScene);
        syncGridsFromMem();
        updateMemDisplay();
      }

      if (EVOLVE.humanize > 0 && evolveCounter % EVOLVE.humanizeInt === 0) {
        DrumMind.humanize(EVOLVE.humanize);
      }
    }

    // ============ LFO AUTOMATION ============
    let lfoActive = false;
    let lfoPhase = 0;
    let lfoTargets = []; // Which params are modulated

    const LFO = {
      rate: 0.1, // Phase increment per step
      depth: 0.3, // Modulation depth (0-1)

      tick() {
        if (!lfoActive) return;

        lfoPhase += this.rate;
        if (lfoPhase > Math.PI * 2) lfoPhase -= Math.PI * 2;

        const modValue = Math.sin(lfoPhase);

        // Modulate bass filter
        const baseFilt = document.getElementById('param-bass-filt');
        if (baseFilt) {
          const baseVal = 70;
          const mod = Math.floor(modValue * this.depth * 50);
          const newVal = Math.max(0, Math.min(127, baseVal + mod));
          baseFilt.value = newVal;
          document.getElementById('val-bass-filt').innerText = newVal;

          // Apply to all active bass steps
          for (let i = 0; i < 16; i++) {
            if (MEM[0x1200 + i]) MEM[0x1220 + i] = newVal;
          }
        }

        // Modulate noise decay
        const noiseDecay = document.getElementById('param-noise-y');
        if (noiseDecay) {
          const baseVal = 8;
          const mod = Math.floor(modValue * this.depth * 6);
          const newVal = Math.max(1, Math.min(15, baseVal + mod));
          noiseDecay.value = newVal;
          document.getElementById('val-noise-y').innerText = newVal;

          for (let i = 0; i < 16; i++) {
            if (MEM[0x1300 + i]) MEM[0x1310 + i] = newVal;
          }
        }

        // Update LED
        const led = document.getElementById('lfo-led');
        led.style.opacity = 0.5 + modValue * 0.5;
      }
    };

    function toggleLFO() {
      lfoActive = !lfoActive;
      const btn = document.getElementById('btn-lfo');
      const led = document.getElementById('lfo-led');

      if (lfoActive) {
        btn.classList.add('primary');
        led.classList.add('active');
        document.getElementById('status').innerText = 'LFO: MODULATING BASS+NOISE';
      } else {
        btn.classList.remove('primary');
        led.classList.remove('active');
        led.style.opacity = 1;
        document.getElementById('status').innerText = 'LFO: OFF';
      }
    }

    function cycleScale() {
      currentScaleIdx = (currentScaleIdx + 1) % SCALE_ORDER.length;
      const scaleName = SCALE_ORDER[currentScaleIdx];
      currentScale = SCALES[scaleName];
      document.getElementById('scale-display').innerText = scaleName;
      document.getElementById('status').innerText = `SCALE: ${scaleName} [${currentScale.intervals.join(',')}]`;
      TIMELINE.record('scale', { scale: scaleName });
    }

    // ============ MICROTUNING SYSTEM ============
    // Memory: $10A0 = tuning mode, $10A1-$10A2 = A4 ref (16-bit Hz), $10A3-$10A7 = per-voice cents (5 bytes)
    const TUNING_ADDR = 0x10A0;

    // Colundi frequencies from Aleksi Perälä / Ovuca
    const COLUNDI = [
      33.7, 55, 87.7, 118, 136.1, 174.6, 210.8, 221.2, 241.5, 282.6, 344.5, 396.7, 470.9, 570.2,
      695.3, 728.1, 802, 880, 1027.5, 1174.7, 1200, 1334.3, 1396.9, 1440, 1587.1, 1642.4, 1768.6,
      1962, 2280, 2400, 2480, 2816, 3000, 3440, 3960, 4216, 4800, 5156, 6000, 7056, 8192, 8400,
      9840, 12000, 14400, 16800, 19600
    ];

    // Just Intonation ratios (pure intervals)
    const JUST_RATIOS = [1, 16/15, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 8/5, 5/3, 9/5, 15/8];

    // Pythagorean ratios (perfect fifths)
    const PYTH_RATIOS = [1, 256/243, 9/8, 32/27, 81/64, 4/3, 729/512, 3/2, 128/81, 27/16, 16/9, 243/128];

    const TUNING_MODES = ['12-TET', 'JUST', 'PYTH', 'COLUNDI'];
    let currentTuning = 0; // 0=12-TET, 1=Just, 2=Pythagorean, 3=Colundi
    let a4Reference = 440;
    let voiceDetune = [0, 0, 0, 0, 0]; // cents offset per voice (kick, snare, lead, bass, noise)

    // Standard 12-TET conversion
    const midiHz = m => a4Reference * Math.pow(2, (m - 69) / 12);

    // Convert MIDI note to Hz respecting current tuning mode
    function noteToHz(midiNote, voiceIndex = 2) {
      const detuneCents = voiceDetune[voiceIndex] || 0;
      const detuneRatio = Math.pow(2, detuneCents / 1200);

      if (currentTuning === 3) {
        // Colundi mode: map MIDI range to Colundi frequencies
        // Filter to playable range (roughly 60-2000 Hz for melodic use)
        const playable = COLUNDI.filter(f => f >= 60 && f <= 2000);
        const idx = Math.max(0, Math.min(playable.length - 1, midiNote - 36));
        return playable[idx] * detuneRatio;
      }

      if (currentTuning === 1 || currentTuning === 2) {
        // Just Intonation or Pythagorean
        const ratios = currentTuning === 1 ? JUST_RATIOS : PYTH_RATIOS;
        const octave = Math.floor((midiNote - 69) / 12);
        const degree = ((midiNote - 69) % 12 + 12) % 12;
        const baseHz = a4Reference * Math.pow(2, octave);
        return baseHz * ratios[degree] * detuneRatio;
      }

      // 12-TET (default)
      return midiHz(midiNote) * detuneRatio;
    }

    // Get tuning mode from memory
    function getTuningMode() {
      return MEM[TUNING_ADDR] || 0;
    }

    // Set tuning mode
    function setTuningMode(mode) {
      currentTuning = mode % TUNING_MODES.length;
      MEM[TUNING_ADDR] = currentTuning;
      updateTuningDisplay();
      saveToLocalStorage();
    }

    // Cycle through tuning modes
    function cycleTuning() {
      setTuningMode((currentTuning + 1) % TUNING_MODES.length);
      document.getElementById('status').innerText = `TUNING: ${TUNING_MODES[currentTuning]}`;
    }

    // Set A4 reference frequency
    function setA4Reference(hz) {
      a4Reference = Math.max(400, Math.min(480, hz)); // Reasonable range
      MEM[TUNING_ADDR + 1] = a4Reference & 0xFF;
      MEM[TUNING_ADDR + 2] = (a4Reference >> 8) & 0xFF;
      updateTuningDisplay();
      saveToLocalStorage();
    }

    // Set per-voice detune in cents
    function setVoiceDetune(voiceIdx, cents) {
      voiceDetune[voiceIdx] = Math.max(-100, Math.min(100, cents));
      MEM[TUNING_ADDR + 3 + voiceIdx] = (voiceDetune[voiceIdx] + 128) & 0xFF; // Store as 0-255
      saveToLocalStorage();
    }

    // Update tuning display
    function updateTuningDisplay() {
      const el = document.getElementById('tuning-display');
      if (el) {
        el.innerText = `${TUNING_MODES[currentTuning]} A=${a4Reference}`;
      }
    }

    // Load tuning from memory
    function loadTuningFromMem() {
      currentTuning = MEM[TUNING_ADDR] || 0;
      const lo = MEM[TUNING_ADDR + 1] || 0;
      const hi = MEM[TUNING_ADDR + 2] || 0;
      if (lo || hi) a4Reference = lo | (hi << 8);
      for (let i = 0; i < 5; i++) {
        const stored = MEM[TUNING_ADDR + 3 + i];
        if (stored !== undefined && stored !== 0) {
          voiceDetune[i] = stored - 128;
        }
      }
      updateTuningDisplay();
    }

    // ============ VOICE CONFIG ============
    // Memory map: $1400-$144F = probability (5×16), $1450-$149F = ratchets (5×16)
    // synth: default synth algorithm name, synthAddr: memory address for synth selector
    // ADSR: 4 bytes per voice at $1060-$1073 (A, D, S, R) - values 0-255, scaled to ms/level
    const VOICES = {
      kick:  { gate: 0x1000, prob: 0x1400, ratch: 0x1450, synth: 'kick', synthAddr: 0x1058, adsr: 0x1060, params: [{ addr: 0x1010, id: 'kick-pitch', def: 36 }] },
      snare: { gate: 0x1020, prob: 0x1410, ratch: 0x1460, synth: 'snare', synthAddr: 0x1059, adsr: 0x1064, params: [{ addr: 0x1030, id: 'snare-tone', def: 180 }, { addr: 0x1040, id: 'snare-snap', def: 100 }] },
      lead:  { gate: 0x1100, prob: 0x1420, ratch: 0x1470, synth: 'lead', synthAddr: 0x115A, adsr: 0x1068, params: [{ addr: 0x1110, id: 'lead-arp', def: 0 }], isNote: true },
      bass:  { gate: 0x1200, prob: 0x1430, ratch: 0x1480, synth: 'bass', synthAddr: 0x125A, adsr: 0x106C, params: [{ addr: 0x1210, id: 'bass-fm', def: 40 }, { addr: 0x1220, id: 'bass-filt', def: 70 }], isNote: true },
      noise: { gate: 0x1300, prob: 0x1440, ratch: 0x1490, synth: 'noise', synthAddr: 0x135A, adsr: 0x1070, params: [{ addr: 0x1310, id: 'noise-y', def: 14 }, { addr: 0x1320, id: 'noise-type', def: 0 }] }
    };

    // ============ INIT ============
    function initGrids() {
      Object.keys(VOICES).forEach(voice => {
        const grid = document.getElementById(`grid-${voice}`);
        grid.innerHTML = '';
        for (let i = 0; i < 16; i++) {
          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          cell.dataset.step = i;
          cell.dataset.voice = voice;
          cell.onclick = () => toggleStep(voice, i);
          grid.appendChild(cell);
        }
      });
    }

    function initMem() {
      const md = document.getElementById('mem-display');
      md.innerHTML = '';

      // Memory map header - like a real debugger
      const header = document.createElement('div');
      header.className = 'mem-header';
      header.innerHTML = '<span class="mem-label">ADDR</span>' +
        Array.from({ length: 16 }, (_, i) => `<span class="mem-col-hdr">+${i.toString(16).toUpperCase()}</span>`).join('');
      md.appendChild(header);

      // Memory regions with descriptive labels
      const rows = [
        ['$1000', 0x1000, 'KICK.GATE'],
        ['$1020', 0x1020, 'SNAR.GATE'],
        ['$1100', 0x1100, 'LEAD.NOTE'],
        ['$1200', 0x1200, 'BASS.NOTE'],
        ['$1300', 0x1300, 'NOIS.GATE']
      ];
      rows.forEach(([addr, base, desc]) => {
        const row = document.createElement('div');
        row.className = 'mem-row';
        row.innerHTML = `<span class="mem-label" title="${desc}">${addr}</span>` +
          Array.from({ length: 16 }, (_, i) =>
            `<div class="mem-cell" id="m${base.toString(16)}_${i}" title="$${(base + i).toString(16).toUpperCase()}"></div>`
          ).join('');
        md.appendChild(row);
      });

      // Memory map legend
      const legend = document.createElement('div');
      legend.className = 'mem-legend';
      legend.innerHTML = `
        <span title="Memory-mapped I/O region">$1000-$13FF MMIO</span>
        <span class="mem-region kick">KICK</span>
        <span class="mem-region snare">SNAR</span>
        <span class="mem-region lead">LEAD</span>
        <span class="mem-region bass">BASS</span>
        <span class="mem-region noise">NOIS</span>
      `;
      md.appendChild(legend);

      ctx.fillStyle = C[0];
      ctx.fillRect(0, 0, 160, 144);

      // Try loading from localStorage first
      if (loadFromLocalStorage()) {
        // Restore saved state
        loadFromScene(currentScene);
        document.getElementById('tempo-display').innerText = tempo;
        document.getElementById('swing-display').innerText = 'SW ' + swing + '%';
        document.getElementById('genre-display').innerText = baseGenre || 'CUSTOM';
        const scaleName = Object.keys(SCALES).find(k => SCALES[k] === currentScale) || 'PENTA';
        document.getElementById('scale-display').innerText = scaleName;
        document.querySelectorAll('.scene-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`.scene-btn[data-scene="${currentScene}"]`).classList.add('active');
        document.getElementById('status').innerText = 'RESTORED FROM AUTOSAVE';
        syncSlidersFromMem();
        loadTuningFromMem(); // Restore tuning state
      } else {
        // Default boot: House + Minor + Evolve ON
        const houseIdx = DrumMind.genres.findIndex(g => g.name === 'HOUSE');
        DrumMind.applyGenre(houseIdx >= 0 ? houseIdx : 0);

        // Set Minor scale
        currentScale = SCALES.MINOR;
        document.getElementById('scale-display').innerText = 'MINOR';

        // Swing 0
        swing = 0;
        document.getElementById('swing-display').innerText = 'SW 0%';

        // Turn on evolve by default
        setTimeout(() => {
          evolveActive = true;
          const evoBtn = document.getElementById('btn-evolve');
          evoBtn.classList.add('evolve-active');
          evoBtn.classList.add('active');
          document.getElementById('evolve-panel').classList.add('open');
          document.getElementById('status').innerText = 'HOUSE MINOR + EVOLVE';
        }, 100);

        // Initialize tuning display
        updateTuningDisplay();
      }
    }

    function loadDefaultPattern() {
      // Legacy fallback - now we use random genre on boot
      // Kick: four on the floor
      [0, 4, 8, 12].forEach(i => { MEM[0x1000 + i] = 1; MEM[0x1010 + i] = 36; });
      // Snare: 2 and 4
      [4, 12].forEach(i => { MEM[0x1020 + i] = 1; MEM[0x1030 + i] = 180; MEM[0x1040 + i] = 100; });
      // Lead: simple melody
      MEM[0x1100] = 60; MEM[0x1100 + 3] = 64; MEM[0x1100 + 6] = 67; MEM[0x1100 + 10] = 60;
      // Bass: root notes
      MEM[0x1200] = 36; MEM[0x1200 + 8] = 36; MEM[0x1210] = 40; MEM[0x1210 + 8] = 40; MEM[0x1220] = 70; MEM[0x1220 + 8] = 70;
      // Noise: hi-hats
      for (let i = 0; i < 16; i += 2) { MEM[0x1300 + i] = 1; MEM[0x1310 + i] = 14; }
      // Save to scene A
      saveToScene(0);
      syncGridsFromMem();
    }

    // ============ MASTER EFFECTS BUS ============
    // All voices connect here → effects chain → destination
    let masterBus = null;
    let masterGain = null;
    let masterFilter = null;
    let masterDelay = null;
    let masterDelayGain = null;
    let masterBitcrush = null;

    // XFX Memory Map: $1080-$10BF
    const XFX = {
      BITCRUSH_BITS:   0x105D,  // 8=normal, 4=crunchy, 2=gameboy, 1=pulse
      BITCRUSH_RATE:   0x105E,  // Sample rate reduction (0-3)
      FILTER_TYPE:     0x1080,  // 0=off, 1=LP, 2=HP, 3=BP, 4=Notch
      FILTER_CUTOFF:   0x1081,  // 0-255 → 100Hz-8000Hz
      FILTER_RESO:     0x1082,  // 0-255 → Q 0.5-20
      FILTER_ENV:      0x1083,  // Envelope amount
      DELAY_TIME_LO:   0x1090,  // Delay ms low byte
      DELAY_TIME_HI:   0x1091,  // Delay ms high byte
      DELAY_FEEDBACK:  0x1092,  // 0-255 → 0-90% feedback
      DELAY_MIX:       0x1093,  // 0-255 → dry/wet
      MASTER_VOL:      0x10A8,  // Master volume 0-255
    };

    // XFM Memory Map: $1400-$144F
    const XFM = {
      OP1_RATIO:    0x1400,  // Frequency ratio (0-255 → 0.5x-16x)
      OP1_LEVEL:    0x1401,  // Output level
      OP1_FEEDBACK: 0x1402,  // Self-modulation
      OP1_WAVE:     0x1403,  // Waveform (0=sin, 1=saw, 2=sq, 3=tri)
      OP2_RATIO:    0x1404,
      OP2_LEVEL:    0x1405,
      OP2_FEEDBACK: 0x1406,
      OP2_WAVE:     0x1407,
      OP3_RATIO:    0x1408,
      OP3_LEVEL:    0x1409,
      OP3_FEEDBACK: 0x140A,
      OP3_WAVE:     0x140B,
      OP4_RATIO:    0x140C,
      OP4_LEVEL:    0x140D,
      OP4_FEEDBACK: 0x140E,
      OP4_WAVE:     0x140F,
      ALGORITHM:    0x1410,  // 0-7: operator routing
      GLOBAL_FB:    0x1411,  // Global feedback
      // ADSR for each operator
      OP1_A: 0x1420, OP1_D: 0x1421, OP1_S: 0x1422, OP1_R: 0x1423,
      OP2_A: 0x1424, OP2_D: 0x1425, OP2_S: 0x1426, OP2_R: 0x1427,
      OP3_A: 0x1428, OP3_D: 0x1429, OP3_S: 0x142A, OP3_R: 0x142B,
      OP4_A: 0x142C, OP4_D: 0x142D, OP4_S: 0x142E, OP4_R: 0x142F,
    };

    // Initialize XFM defaults (DX7-style electric piano)
    function initXFMDefaults() {
      MEM[XFM.OP1_RATIO] = 32;   // 1x
      MEM[XFM.OP1_LEVEL] = 200;
      MEM[XFM.OP1_WAVE] = 0;     // sine
      MEM[XFM.OP2_RATIO] = 64;   // 2x
      MEM[XFM.OP2_LEVEL] = 150;
      MEM[XFM.OP2_WAVE] = 0;
      MEM[XFM.OP3_RATIO] = 96;   // 3x
      MEM[XFM.OP3_LEVEL] = 100;
      MEM[XFM.OP3_WAVE] = 0;
      MEM[XFM.OP4_RATIO] = 224;  // 7x (metallic)
      MEM[XFM.OP4_LEVEL] = 80;
      MEM[XFM.OP4_WAVE] = 0;
      MEM[XFM.ALGORITHM] = 0;
      // Fast attack, medium decay for bell-like
      MEM[XFM.OP1_A] = 5; MEM[XFM.OP1_D] = 100; MEM[XFM.OP1_S] = 60; MEM[XFM.OP1_R] = 80;
      MEM[XFM.OP2_A] = 5; MEM[XFM.OP2_D] = 60;  MEM[XFM.OP2_S] = 30; MEM[XFM.OP2_R] = 60;
      MEM[XFM.OP3_A] = 5; MEM[XFM.OP3_D] = 40;  MEM[XFM.OP3_S] = 20; MEM[XFM.OP3_R] = 50;
      MEM[XFM.OP4_A] = 5; MEM[XFM.OP4_D] = 20;  MEM[XFM.OP4_S] = 10; MEM[XFM.OP4_R] = 30;
    }

    // Initialize XFX defaults
    function initXFXDefaults() {
      MEM[XFX.BITCRUSH_BITS] = 0;   // Off (0 = no crush)
      MEM[XFX.BITCRUSH_RATE] = 0;   // No rate reduction
      MEM[XFX.FILTER_TYPE] = 0;     // Off
      MEM[XFX.FILTER_CUTOFF] = 200; // High cutoff
      MEM[XFX.FILTER_RESO] = 30;    // Low resonance
      MEM[XFX.DELAY_TIME_LO] = 0;   // No delay
      MEM[XFX.DELAY_TIME_HI] = 0;
      MEM[XFX.DELAY_FEEDBACK] = 80;
      MEM[XFX.DELAY_MIX] = 60;
      MEM[XFX.MASTER_VOL] = 200;
    }

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new AudioContext();

        // Create master effects chain
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.8;

        // Master filter (controlled by XFX)
        masterFilter = audioCtx.createBiquadFilter();
        masterFilter.type = 'lowpass';
        masterFilter.frequency.value = 8000;
        masterFilter.Q.value = 1;

        // Delay effect
        masterDelay = audioCtx.createDelay(2.0);
        masterDelay.delayTime.value = 0;
        masterDelayGain = audioCtx.createGain();
        masterDelayGain.gain.value = 0;

        // Connect: masterGain → filter → destination
        //                    ↘→ delay → delayGain ↗ (feedback loop)
        masterGain.connect(masterFilter);
        masterFilter.connect(audioCtx.destination);
        masterGain.connect(masterDelay);
        masterDelay.connect(masterDelayGain);
        masterDelayGain.connect(masterFilter);
        masterDelayGain.connect(masterDelay); // feedback

        // Set masterBus as the target for all voices
        masterBus = masterGain;

        // Initialize pack defaults
        initXFMDefaults();
        initXFXDefaults();
        initXSIDDefaults();

        // Start effects update loop
        setInterval(updateMasterEffects, 50);

        document.getElementById('led').classList.add('on');
      }
      document.getElementById('status').innerText = 'AUDIO READY [XFM+XFX]';
    }

    // Update master effects from memory (called periodically)
    function updateMasterEffects() {
      if (!audioCtx || !masterFilter) return;

      // Master volume
      const vol = MEM[XFX.MASTER_VOL] || 200;
      masterGain.gain.value = vol / 255;

      // Filter
      const filterType = MEM[XFX.FILTER_TYPE] || 0;
      if (filterType > 0) {
        const types = ['lowpass', 'lowpass', 'highpass', 'bandpass', 'notch'];
        masterFilter.type = types[filterType] || 'lowpass';
        const cutoff = MEM[XFX.FILTER_CUTOFF] || 200;
        masterFilter.frequency.value = 100 + (cutoff / 255) * 7900;
        const reso = MEM[XFX.FILTER_RESO] || 30;
        masterFilter.Q.value = 0.5 + (reso / 255) * 19.5;
      } else {
        masterFilter.frequency.value = 20000; // Bypass
        masterFilter.Q.value = 0.5;
      }

      // Delay
      const delayMs = MEM[XFX.DELAY_TIME_LO] + (MEM[XFX.DELAY_TIME_HI] << 8);
      if (delayMs > 0) {
        masterDelay.delayTime.value = Math.min(delayMs / 1000, 2.0);
        const fb = MEM[XFX.DELAY_FEEDBACK] || 0;
        masterDelayGain.gain.value = (fb / 255) * 0.9 * (MEM[XFX.DELAY_MIX] / 255);
      } else {
        masterDelayGain.gain.value = 0;
      }
    }

    // Get audio destination (use master bus if available, else direct)
    function getAudioDest() {
      return masterBus || audioCtx.destination;
    }

    // ============ GRID INTERACTION ============
    // Mark memory addresses as "hot" for heat visualization
    function markHot(addr) {
      MEM_HEAT[addr] = 255;
      MEM_WRITES[addr]++;
      BUS.bytesWritten++;
      BUS.lastAddr = addr;
      BUS.lastOp = 'WRITE';
      CPU.cycles++;
    }

    // Mark a range of addresses as hot
    function markHotRange(start, count) {
      for (let i = 0; i < count; i++) {
        markHot(start + i);
      }
    }

    function toggleStep(voice, stepIdx) {
      const v = VOICES[voice];
      const addr = v.gate + stepIdx;

      if (MEM[addr]) {
        // Turn off
        MEM[addr] = 0;
        markHot(addr);
        v.params.forEach(p => {
          MEM[p.addr + stepIdx] = 0;
          markHot(p.addr + stepIdx);
        });
        // Reset prob/ratch to defaults
        MEM[v.prob + stepIdx] = 0;  // 0 = 100%
        MEM[v.ratch + stepIdx] = 0; // 0 = 1 hit
        markHot(v.prob + stepIdx);
        markHot(v.ratch + stepIdx);
      } else {
        // Turn on with current param values
        if (v.isNote) {
          const noteSlider = document.getElementById(`param-${voice}-note`);
          MEM[addr] = noteSlider ? parseInt(noteSlider.value) : 60;
        } else {
          MEM[addr] = 1;
        }
        markHot(addr);
        v.params.forEach(p => {
          const el = document.getElementById(`param-${p.id}`);
          MEM[p.addr + stepIdx] = el ? parseInt(el.value) : p.def;
          markHot(p.addr + stepIdx);
        });
        // Set prob/ratch from current slider values
        const probSlider = document.getElementById(`param-${voice}-prob`);
        const ratchSlider = document.getElementById(`param-${voice}-ratch`);
        MEM[v.prob + stepIdx] = probSlider ? parseInt(probSlider.value) : 0;
        MEM[v.ratch + stepIdx] = ratchSlider ? parseInt(ratchSlider.value) : 1;
        markHot(v.prob + stepIdx);
        markHot(v.ratch + stepIdx);
      }
      saveToScene(currentScene);
      syncGridsFromMem();
      updateMemDisplay();
      drawLCD();
    }

    function syncGridsFromMem() {
      Object.keys(VOICES).forEach(voice => {
        const v = VOICES[voice];
        const cells = document.querySelectorAll(`#grid-${voice} .grid-cell`);
        cells.forEach((cell, i) => {
          const val = MEM[v.gate + i];
          cell.classList.toggle('active', val > 0);
          cell.classList.toggle('beat', isPlaying && i === step);
          cell.innerText = val > 0 ? (v.isNote ? midiToName(val) : val) : '';
        });
      });
    }

    // Sync all parameter sliders from memory
    function syncSlidersFromMem() {
      // Map slider IDs to memory addresses
      const sliderMap = {
        'param-kick-pitch': 0x1010,
        'param-snare-tone': 0x1030,
        'param-snare-snap': 0x1040,
        'param-bass-fm': 0x1210,
        'param-bass-filt': 0x1220,
        'param-noise-y': 0x1310
      };

      Object.entries(sliderMap).forEach(([id, addr]) => {
        const slider = document.getElementById(id);
        if (slider && MEM[addr] !== undefined) {
          slider.value = MEM[addr];
          // Update associated display
          const display = document.getElementById('val-' + id.replace('param-', ''));
          if (display) display.innerText = MEM[addr];
        }
      });

      // Sync tempo and swing
      const tempoSlider = document.getElementById('tempo-slider');
      if (tempoSlider) tempoSlider.value = MEM[0x1501] || tempo;

      // Sync ADSR sliders from MEM
      document.querySelectorAll('.adsr-slider').forEach(slider => {
        const voice = slider.dataset.voice;
        const param = parseInt(slider.dataset.param);
        const baseAddr = VOICES[voice].adsr;
        if (MEM[baseAddr + param] !== undefined) {
          slider.value = MEM[baseAddr + param];
        }
      });
    }

    // ============ RANDOMIZE / EUCLIDEAN / CLEAR ============
    // TRUE RANDOM - every step gets random gate AND random params
    function randomizeVoice(voice) {
      const v = VOICES[voice];

      for (let i = 0; i < 16; i++) {
        // Random gate - true random, no density bias
        const gateOn = Math.random() < 0.5;

        if (gateOn) {
          if (v.isNote) {
            // Random note from current scale
            const root = voice === 'bass' ? 36 : 60;
            MEM[v.gate + i] = quantize(root, root);
          } else {
            MEM[v.gate + i] = 1;
          }
        } else {
          MEM[v.gate + i] = 0;
        }

        // ALWAYS randomize params for EVERY step (even if gate is off)
        // This creates interesting p-locks when you later turn steps on
        v.params.forEach(p => {
          const el = document.getElementById(`param-${p.id}`);
          const min = el ? parseInt(el.min) : 0;
          const max = el ? parseInt(el.max) : 127;
          MEM[p.addr + i] = min + Math.floor(Math.random() * (max - min + 1));
        });
      }
      saveToScene(currentScene);
      syncGridsFromMem();
      updateMemDisplay();
      document.getElementById('status').innerText = `${voice.toUpperCase()} TRUE RND`;
    }

    // TRUE EUCLIDEAN - click cycles pulses (1-16), shift+click adjusts rotation
    let eucPulses = { kick: 4, snare: 2, lead: 5, bass: 3, noise: 8 };
    let eucRotation = { kick: 0, snare: 0, lead: 0, bass: 0, noise: 0 };

    function trueEuclidVoice(voice, event) {
      const v = VOICES[voice];

      // Shift+click adjusts rotation, normal click adjusts pulses
      if (event && event.shiftKey) {
        eucRotation[voice] = (eucRotation[voice] + 1) % 16;
      } else {
        eucPulses[voice] = (eucPulses[voice] % 16) + 1;
      }

      // Generate TRUE euclidean pattern using Bjorklund
      const pattern = bjorklund(16, eucPulses[voice], eucRotation[voice]);

      for (let i = 0; i < 16; i++) {
        if (pattern[i]) {
          if (v.isNote) {
            const root = voice === 'bass' ? 36 : 60;
            MEM[v.gate + i] = quantize(root, root);
          } else {
            MEM[v.gate + i] = 1;
          }
          v.params.forEach(p => {
            const el = document.getElementById(`param-${p.id}`);
            MEM[p.addr + i] = el ? parseInt(el.value) : p.def;
          });
        } else {
          MEM[v.gate + i] = 0;
        }
      }

      saveToScene(currentScene);
      syncGridsFromMem();
      updateMemDisplay();
      document.getElementById('status').innerText = `${voice.toUpperCase()} E(16,${eucPulses[voice]},${eucRotation[voice]})`;
    }

    // ============ GLOBAL PATTERN TRANSFORMS ============
    function rotateAllPatterns(amount) {
      Object.keys(VOICES).forEach(voice => {
        const v = VOICES[voice];
        const gates = [];
        const params = {};

        // Read current pattern
        for (let i = 0; i < 16; i++) gates[i] = MEM[v.gate + i];
        v.params.forEach(p => {
          params[p.addr] = [];
          for (let i = 0; i < 16; i++) params[p.addr][i] = MEM[p.addr + i];
        });

        // Rotate
        const rotated = rotatePattern(gates, amount);
        const rotatedParams = {};
        v.params.forEach(p => {
          rotatedParams[p.addr] = rotatePattern(params[p.addr], amount);
        });

        // Write back
        for (let i = 0; i < 16; i++) MEM[v.gate + i] = rotated[i];
        v.params.forEach(p => {
          for (let i = 0; i < 16; i++) MEM[p.addr + i] = rotatedParams[p.addr][i];
        });
      });

      saveToScene(currentScene);
      syncGridsFromMem();
      updateMemDisplay();
      document.getElementById('status').innerText = `ROTATED ${amount > 0 ? 'RIGHT' : 'LEFT'}`;
    }

    function applyLifeToAll() {
      Object.keys(VOICES).forEach(voice => {
        const v = VOICES[voice];
        const gates = [];
        for (let i = 0; i < 16; i++) gates[i] = MEM[v.gate + i] ? 1 : 0;

        // Apply cellular automata
        const next = conwayStep(gates);

        for (let i = 0; i < 16; i++) {
          if (next[i] && !gates[i]) {
            // Birth - new step
            if (v.isNote) {
              MEM[v.gate + i] = quantize(voice === 'bass' ? 36 : 60);
            } else {
              MEM[v.gate + i] = 1;
            }
            v.params.forEach(p => MEM[p.addr + i] = p.def);
          } else if (!next[i] && gates[i]) {
            // Death
            MEM[v.gate + i] = 0;
          }
          // Survival keeps existing value
        }
      });

      saveToScene(currentScene);
      syncGridsFromMem();
      updateMemDisplay();
      document.getElementById('status').innerText = 'LIFE STEP APPLIED';
    }

    function invertAllPatterns() {
      Object.keys(VOICES).forEach(voice => {
        const v = VOICES[voice];
        for (let i = 0; i < 16; i++) {
          if (MEM[v.gate + i]) {
            MEM[v.gate + i] = 0;
          } else {
            if (v.isNote) {
              MEM[v.gate + i] = quantize(voice === 'bass' ? 36 : 60);
            } else {
              MEM[v.gate + i] = 1;
            }
            v.params.forEach(p => MEM[p.addr + i] = p.def);
          }
        }
      });

      saveToScene(currentScene);
      syncGridsFromMem();
      updateMemDisplay();
      document.getElementById('status').innerText = 'PATTERNS INVERTED';
    }

    // Pattern presets for each voice - cycle through with PAT button
    const PATTERNS = {
      kick: [
        { p: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0], label: '4/4 FOUR ON FLOOR' },
        { p: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0], label: '1 & 3' },
        { p: [1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0], label: '1 & 3.5' },
        { p: [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0], label: 'SHUFFLE' },
        { p: [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0], label: 'DNB 2-STEP' },
        { p: [1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0], label: 'BREAKBEAT' },
        { p: [1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0], label: 'SYNTH-POP' },
      ],
      snare: [
        { p: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], label: 'BACKBEAT 2&4' },
        { p: [0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1], label: 'EVERY 3RD' },
        { p: [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0], label: 'HALFTIME (3)' },
        { p: [0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0], label: 'DUBSTEP' },
        { p: [0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0], label: 'DNB' },
        { p: [0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1], label: 'BREAKBEAT' },
        { p: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0], label: 'DISCO' },
      ],
      noise: [
        { p: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], label: 'EVENS (8THS)' },
        { p: [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1], label: 'ODDS (OFFBEAT)' },
        { p: [1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1], label: 'EVERY 3RD' },
        { p: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], label: '16THS (ALL)' },
        { p: [1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0], label: 'OPEN-CLOSED' },
        { p: [1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1], label: 'FILL END' },
        { p: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0], label: 'SPARSE' },
      ],
      lead: [
        { p: [60,0,0,0,64,0,0,0,67,0,0,0,64,0,0,0], label: 'ARPEGGIO' },
        { p: [60,0,0,60,0,0,60,0,60,0,0,60,0,0,60,0], label: 'PULSE' },
        { p: [60,0,67,0,0,0,64,0,0,0,67,0,60,0,0,0], label: 'MELODIC' },
        { p: [60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], label: 'SPARSE' },
        { p: [60,60,0,0,67,67,0,0,64,64,0,0,72,0,0,0], label: 'STAB' },
        { p: [60,62,64,65,67,65,64,62,60,0,0,0,0,0,0,0], label: 'RUN UP' },
        { p: [72,0,67,0,64,0,60,0,0,0,0,0,0,0,0,0], label: 'RUN DOWN' },
      ],
      bass: [
        { p: [36,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0], label: 'ROOT 1&3' },
        { p: [36,0,0,0,36,0,0,0,36,0,0,0,36,0,0,0], label: 'FOUR' },
        { p: [36,0,0,36,0,0,36,0,0,36,0,0,36,0,0,0], label: 'DRIVIN' },
        { p: [36,0,0,0,0,0,43,0,36,0,0,0,0,0,41,0], label: 'ROOT-5TH' },
        { p: [36,0,36,0,0,0,36,0,0,0,36,0,0,36,0,0], label: 'SYNCOPATED' },
        { p: [36,36,0,0,36,0,0,36,36,0,0,0,36,0,36,0], label: 'REESE DNB' },
        { p: [36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], label: 'SPARSE DROP' },
      ],
    };

    function euclidVoice(voice) {
      const v = VOICES[voice];
      const presets = PATTERNS[voice];
      const mode = presets[eucModes[voice]];
      eucModes[voice] = (eucModes[voice] + 1) % presets.length;

      for (let i = 0; i < 16; i++) {
        const val = mode.p[i];
        if (val) {
          MEM[v.gate + i] = v.isNote ? val : 1;
          v.params.forEach(p => {
            const el = document.getElementById(`param-${p.id}`);
            MEM[p.addr + i] = el ? parseInt(el.value) : p.def;
          });
        } else {
          MEM[v.gate + i] = 0;
        }
      }
      saveToScene(currentScene);
      syncGridsFromMem();
      updateMemDisplay();
      document.getElementById('status').innerText = `${voice.toUpperCase()} ${mode.label}`;
    }

    function clearVoice(voice) {
      const v = VOICES[voice];
      for (let i = 0; i < 16; i++) {
        MEM[v.gate + i] = 0;
        v.params.forEach(p => MEM[p.addr + i] = 0);
      }
      saveToScene(currentScene);
      syncGridsFromMem();
      updateMemDisplay();
      document.getElementById('status').innerText = `${voice.toUpperCase()} CLEARED`;
    }

    function mutateAll() {
      // Respects EVOLVE settings per voice
      Object.keys(VOICES).forEach(voice => {
        const v = VOICES[voice];
        const evoSettings = EVOLVE.voices[voice];

        // Skip if voice is disabled or not configured
        if (!evoSettings || !evoSettings.on) return;

        // Use evolve amount as mutation probability (0-100 → 0.0-0.15)
        const mutationChance = (evoSettings.amt / 100) * 0.15;

        for (let i = 0; i < 16; i++) {
          if (Math.random() < mutationChance) {
            // Only allow add/remove if enabled in evolve settings
            if (evoSettings.addRm) {
              if (MEM[v.gate + i]) {
                MEM[v.gate + i] = 0;
              } else if (Math.random() < 0.5) {
                MEM[v.gate + i] = v.isNote ? quantize(voice === 'bass' ? 36 : 60) : 1;
                v.params.forEach(p => MEM[p.addr + i] = p.def);
              }
            }
            // Octave shift if enabled
            else if (evoSettings.oct && v.isNote && MEM[v.gate + i]) {
              const note = MEM[v.gate + i];
              const shift = (Math.random() < 0.5 ? 12 : -12);
              const newNote = Math.max(24, Math.min(96, note + shift));
              MEM[v.gate + i] = newNote;
            }
            // Shift timing if enabled
            else if (evoSettings.shift && MEM[v.gate + i]) {
              const shiftDir = Math.random() < 0.5 ? 1 : -1;
              const targetIdx = (i + shiftDir + 16) % 16;
              if (!MEM[v.gate + targetIdx]) {
                MEM[v.gate + targetIdx] = MEM[v.gate + i];
                MEM[v.gate + i] = 0;
                v.params.forEach(p => {
                  MEM[p.addr + targetIdx] = MEM[p.addr + i];
                  MEM[p.addr + i] = 0;
                });
              }
            }
          }
        }
      });
      saveToScene(currentScene);
      syncGridsFromMem();
      updateMemDisplay();
      document.getElementById('status').innerText = 'PATTERN MUTATED (EVOLVE)';
    }

    // ============ SCENE MANAGEMENT ============
    function saveToScene(idx) {
      for (let i = 0; i < 1024; i++) {
        SCENES[idx][i] = MEM[0x1000 + i];
      }
      scheduleAutoSave();
    }

    function loadFromScene(idx) {
      for (let i = 0; i < 1024; i++) {
        MEM[0x1000 + i] = SCENES[idx][i];
      }
    }

    function switchScene(idx) {
      if (copyMode) {
        // Copy current scene to target
        for (let i = 0; i < 1024; i++) {
          SCENES[idx][i] = SCENES[currentScene][i];
        }
        copyMode = false;
        document.querySelectorAll('.scene-btn').forEach(b => b.classList.remove('copy-target'));
        document.getElementById('status').innerText = `COPIED ${String.fromCharCode(65 + currentScene)} → ${String.fromCharCode(65 + idx)}`;
        scheduleAutoSave();
        return;
      }

      // Don't switch to same scene
      if (idx === currentScene) return;

      // Save current before switching
      saveToScene(currentScene);

      // Switch
      currentScene = idx;
      loadFromScene(idx);
      TIMELINE.record('scene', { scene: idx });

      // Update UI with transition animation
      document.querySelectorAll('.scene-btn').forEach(b => {
        b.classList.remove('active', 'transitioning');
      });
      const targetBtn = document.querySelector(`.scene-btn[data-scene="${idx}"]`);
      targetBtn.classList.add('active', 'transitioning');

      // Animate the grid/canvas area
      const lcd = document.getElementById('lcd');
      const memDisplay = document.getElementById('mem-display');
      const voicePanels = document.querySelectorAll('.voice-panel');

      lcd.classList.remove('scene-transition');
      memDisplay.classList.remove('scene-transition');
      voicePanels.forEach(p => p.classList.remove('scene-transition'));

      // Force reflow to restart animation
      void lcd.offsetWidth;

      lcd.classList.add('scene-transition');
      memDisplay.classList.add('scene-transition');
      voicePanels.forEach(p => p.classList.add('scene-transition'));

      syncGridsFromMem();
      updateMemDisplay();
      document.getElementById('status').innerText = `SCENE ${String.fromCharCode(65 + idx)} ($${(0x1000 + idx * 0x400).toString(16).toUpperCase()})`;
    }

    function startCopyMode() {
      copyMode = true;
      document.querySelectorAll('.scene-btn').forEach(b => {
        if (b.dataset.scene != currentScene) b.classList.add('copy-target');
      });
      document.getElementById('status').innerText = 'SELECT TARGET SCENE...';
    }
    // ============ SYNTH REGISTRY ============
    // Pattern: Register synthesis algorithms by name, voices reference them
    // This allows packs to swap synth algorithms, users to add new voices
    const SYNTHS = {};  // name → function(t, params, ctx)

    // Synth lookup tables - index in memory → synth name
    const SYNTH_IDS = {
      kick:  ['kick', 'kick808', 'kick909'],
      snare: ['snare', 'clap', 'rim'],
      lead:  ['lead'],
      bass:  ['bass'],
      noise: ['noise'],
    };

    // Get current synth for a voice (reads from memory!)
    function getVoiceSynth(voiceName) {
      const voice = VOICES[voiceName];
      if (!voice) return null;
      const synthId = MEM[voice.synthAddr] || 0;
      const synthList = SYNTH_IDS[voiceName] || [voice.synth];
      return synthList[synthId] || synthList[0];
    }

    // API: Register a new synth algorithm
    function registerSynth(name, fn) {
      SYNTHS[name] = fn;
      console.log(`[SYNTH] Registered: ${name}`);
    }

    // API: Add a new voice or modify existing
    function registerVoice(name, config) {
      VOICES[name] = { ...VOICES[name], ...config };
      console.log(`[VOICE] Registered: ${name} → synth:${config.synth || VOICES[name]?.synth}`);
    }

    // API: Swap a voice's synth algorithm
    function setVoiceSynth(voiceName, synthName) {
      if (VOICES[voiceName] && SYNTHS[synthName]) {
        VOICES[voiceName].synth = synthName;
        console.log(`[VOICE] ${voiceName} now uses synth: ${synthName}`);
      }
    }

    // Helper: get voice params from memory
    function getVoiceParams(voice, step) {
      return voice.paramAddrs.map(addr => MEM[addr + step]);
    }

    // ============ SYNTH IMPLEMENTATIONS ============
    // Register: SYNTHS['name'] = (t, note, params) => { ... }

    // Character params: 0x1050=decay, 0x1051=sweep, 0x1052=click, 0x1053=sub
    // Kick: parameterized for 808/909 style via character memory
    SYNTHS['kick'] = function(t, note, params) {
      const pitch = params[0] || note;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const f = pitch > 0 ? midiHz(pitch) : 60;
      const decayParam = MEM[0x1050] || 100;
      const sweepParam = MEM[0x1051] || 90;
      const clickParam = MEM[0x1052] || 0;
      const subParam = MEM[0x1053] || 50;
      const decay = 0.15 + (decayParam / 255) * 0.6;
      const sweep = 1.5 + (sweepParam / 255) * 6;
      const clickLevel = clickParam / 255 * 0.4;
      const subLevel = subParam / 255 * 0.5;
      osc.frequency.setValueAtTime(f * sweep, t);
      osc.frequency.exponentialRampToValueAtTime(f, t + 0.06);
      gain.gain.setValueAtTime(0.7, t);
      gain.gain.exponentialRampToValueAtTime(0.01, t + decay);
      osc.connect(gain).connect(getAudioDest());
      osc.start(t); osc.stop(t + decay + 0.05);
      if (clickLevel > 0.05) {
        const click = audioCtx.createOscillator();
        const clickGain = audioCtx.createGain();
        click.type = 'square';
        click.frequency.setValueAtTime(1200, t);
        click.frequency.exponentialRampToValueAtTime(200, t + 0.01);
        clickGain.gain.setValueAtTime(clickLevel, t);
        clickGain.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
        click.connect(clickGain).connect(getAudioDest());
        click.start(t); click.stop(t + 0.03);
      }
      if (subLevel > 0.05) {
        const sub = audioCtx.createOscillator();
        const subGain = audioCtx.createGain();
        sub.type = 'sine';
        sub.frequency.setValueAtTime(f * 0.5, t);
        subGain.gain.setValueAtTime(subLevel, t);
        subGain.gain.exponentialRampToValueAtTime(0.01, t + decay * 1.2);
        sub.connect(subGain).connect(getAudioDest());
        sub.start(t); sub.stop(t + decay * 1.2 + 0.05);
      }
    };

    // Snare: parameterized body/noise balance
    SYNTHS['snare'] = function(t, note, params) {
      const tone = params[0] || 180;
      const snap = params[1] || 100;
      const bodyDecay = MEM[0x1054] || 80;
      const noiseLevel = MEM[0x1055] || 127;
      const bodyTune = MEM[0x1056] || 100;
      const noiseBright = MEM[0x1057] || 150;
      const bodyTime = 0.05 + (bodyDecay / 255) * 0.2;
      const noiseMix = noiseLevel / 255;
      const bodyMix = 1 - (noiseMix * 0.5);
      const hpFreq = 1000 + (noiseBright / 255) * 6000;
      const osc = audioCtx.createOscillator();
      const g1 = audioCtx.createGain();
      osc.type = 'triangle';
      const f = tone > 0 ? tone * (0.5 + bodyTune/255) : 180;
      osc.frequency.setValueAtTime(f * 1.8, t);
      osc.frequency.exponentialRampToValueAtTime(f, t + 0.02);
      g1.gain.setValueAtTime(0.5 * bodyMix, t);
      g1.gain.exponentialRampToValueAtTime(0.01, t + bodyTime);
      osc.connect(g1).connect(getAudioDest());
      osc.start(t); osc.stop(t + bodyTime + 0.05);
      const noiseDecay = snap > 0 ? snap / 1000 : 0.1;
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
      const noise = audioCtx.createBufferSource();
      const filt = audioCtx.createBiquadFilter();
      const g2 = audioCtx.createGain();
      noise.buffer = buf;
      filt.type = 'highpass';
      filt.frequency.value = hpFreq;
      g2.gain.setValueAtTime(0.6 * noiseMix, t);
      g2.gain.exponentialRampToValueAtTime(0.01, t + noiseDecay);
      noise.connect(filt).connect(g2).connect(getAudioDest());
      noise.start(t); noise.stop(t + noiseDecay + 0.05);
    };

    // Lead: square wave with optional arp + ADSR
    SYNTHS['lead'] = function(t, note, params, adsr = {a:0.01, d:0.1, s:0.5, r:0.2}) {
      const arp = params[0] || 0;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const f = noteToHz(note, 2); // voice index 2 = lead
      osc.type = 'square';

      // Vibrato LFO
      const lfo = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      lfo.type = 'sine';
      lfo.frequency.value = 5;
      lfoGain.gain.setValueAtTime(0, t);
      lfoGain.gain.linearRampToValueAtTime(f * 0.02, t + 0.1);
      lfo.connect(lfoGain).connect(osc.frequency);

      if (arp === 1) { // Major arp
        osc.frequency.setValueAtTime(f, t);
        osc.frequency.setValueAtTime(f * 1.26, t + 0.025);
        osc.frequency.setValueAtTime(f * 1.5, t + 0.05);
        osc.frequency.setValueAtTime(f, t + 0.075);
      } else if (arp === 2) { // Minor arp
        osc.frequency.setValueAtTime(f, t);
        osc.frequency.setValueAtTime(f * 1.19, t + 0.025);
        osc.frequency.setValueAtTime(f * 1.5, t + 0.05);
        osc.frequency.setValueAtTime(f, t + 0.075);
      } else {
        osc.frequency.setValueAtTime(f, t);
      }

      // ADSR envelope
      const peakVol = 0.25;
      const sustainVol = peakVol * adsr.s;
      const totalTime = adsr.a + adsr.d + 0.1 + adsr.r;
      gain.gain.setValueAtTime(0.001, t);
      gain.gain.linearRampToValueAtTime(peakVol, t + adsr.a);
      gain.gain.linearRampToValueAtTime(Math.max(0.001, sustainVol), t + adsr.a + adsr.d);
      gain.gain.setValueAtTime(Math.max(0.001, sustainVol), t + adsr.a + adsr.d + 0.1);
      gain.gain.exponentialRampToValueAtTime(0.001, t + totalTime);

      osc.connect(gain).connect(getAudioDest());
      lfo.start(t);
      osc.start(t);
      lfo.stop(t + totalTime);
      osc.stop(t + totalTime + 0.01);
    };

    // Bass: sawtooth with FM and sub + ADSR
    SYNTHS['bass'] = function(t, note, params, adsr = {a:0.005, d:0.1, s:0.7, r:0.15}) {
      const fm = params[0] || 0;
      const filt = params[1] || 50;
      const f = noteToHz(note, 3); // voice index 3 = bass
      const carrier = audioCtx.createOscillator();
      const filter = audioCtx.createBiquadFilter();
      const gain = audioCtx.createGain();
      carrier.type = 'sawtooth';
      carrier.frequency.setValueAtTime(f * 1.5, t);
      carrier.frequency.exponentialRampToValueAtTime(f, t + 0.02);
      if (fm > 0) {
        const mod = audioCtx.createOscillator();
        const mg = audioCtx.createGain();
        mod.frequency.value = f * 1.414;
        mg.gain.setValueAtTime(fm, t);
        mg.gain.exponentialRampToValueAtTime(1, t + 0.1);
        mod.connect(mg).connect(carrier.frequency);
        mod.start(t); mod.stop(t + 0.15);
      }

      // ADSR envelope
      const peakVol = 0.35;
      const sustainVol = peakVol * adsr.s;
      const totalTime = adsr.a + adsr.d + 0.1 + adsr.r;

      // Sub oscillator with ADSR
      const sub = audioCtx.createOscillator();
      const sg = audioCtx.createGain();
      sub.type = 'sine';
      sub.frequency.value = f / 2;
      sg.gain.setValueAtTime(0.001, t);
      sg.gain.linearRampToValueAtTime(peakVol, t + adsr.a);
      sg.gain.linearRampToValueAtTime(Math.max(0.001, sustainVol), t + adsr.a + adsr.d);
      sg.gain.exponentialRampToValueAtTime(0.001, t + totalTime);
      sub.connect(sg).connect(getAudioDest());
      sub.start(t); sub.stop(t + totalTime + 0.01);

      // Main carrier with ADSR
      filter.type = 'lowpass';
      filter.frequency.value = 100 + filt * 60;
      filter.Q.value = 4;
      gain.gain.setValueAtTime(0.001, t);
      gain.gain.linearRampToValueAtTime(peakVol, t + adsr.a);
      gain.gain.linearRampToValueAtTime(Math.max(0.001, sustainVol), t + adsr.a + adsr.d);
      gain.gain.exponentialRampToValueAtTime(0.001, t + totalTime);
      carrier.connect(filter).connect(gain).connect(getAudioDest());
      carrier.start(t); carrier.stop(t + totalTime + 0.01);
    };

    // Noise: hat or zap
    SYNTHS['noise'] = function(t, note, params) {
      const y = params[0] || 5;
      const type = params[1] || 0;
      if (type === 1) { // Zap
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const startF = 2000 + (15 - y) * 200;
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(startF, t);
        osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
        gain.gain.setValueAtTime(0.4, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        osc.connect(gain).connect(getAudioDest());
        osc.start(t); osc.stop(t + 0.15);
      } else { // Hat
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
        const src = audioCtx.createBufferSource();
        const filt = audioCtx.createBiquadFilter();
        const gain = audioCtx.createGain();
        src.buffer = buf;
        filt.type = 'highpass';
        filt.frequency.value = 3000 + y * 400;
        const decay = y > 10 ? 0.03 : 0.08;
        gain.gain.setValueAtTime(0.3, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + decay);
        src.connect(filt).connect(gain).connect(getAudioDest());
        src.start(t); src.stop(t + decay + 0.02);
      }
    };

    // ============ PLAY VOICE (unified interface) ============
    // ADSR helper: returns {a, d, s, r} in seconds/level from MEM bytes
    function getADSR(voiceName) {
      const voice = VOICES[voiceName];
      if (!voice || !voice.adsr) return { a: 0.01, d: 0.1, s: 0.5, r: 0.2 };
      const base = voice.adsr;
      return {
        a: MEM[base] / 255 * 0.5,       // Attack: 0-500ms
        d: MEM[base + 1] / 255 * 0.5,   // Decay: 0-500ms
        s: MEM[base + 2] / 255,         // Sustain: 0-1 level
        r: MEM[base + 3] / 255 * 1.0    // Release: 0-1000ms
      };
    }

    function playVoice(voiceName, t, step) {
      const voice = VOICES[voiceName];
      if (!voice) return;
      const synthFn = SYNTHS[voice.synth];
      if (!synthFn) return;
      const note = MEM[voice.addr + step];
      const params = voice.paramAddrs.map(a => MEM[a + step]);
      const adsr = getADSR(voiceName);
      synthFn(t, note, params, adsr);
    }

    // ============ ALTERNATE SYNTHS (switchable via registry) ============

    // Kick909: punchy, clicky, short - classic techno/house
    SYNTHS['kick909'] = function(t, note, params) {
      const pitch = params[0] || 0;
      const f = pitch > 0 ? midiHz(pitch) : 55;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.exponentialRampToValueAtTime(f, t + 0.05);
      gain.gain.setValueAtTime(1, t);
      gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
      osc.connect(gain).connect(getAudioDest());
      osc.start(t); osc.stop(t + 0.2);
      // Click transient
      const click = audioCtx.createOscillator();
      const cg = audioCtx.createGain();
      click.type = 'square';
      click.frequency.setValueAtTime(1500, t);
      click.frequency.exponentialRampToValueAtTime(100, t + 0.01);
      cg.gain.setValueAtTime(0.3, t);
      cg.gain.exponentialRampToValueAtTime(0.001, t + 0.015);
      click.connect(cg).connect(getAudioDest());
      click.start(t); click.stop(t + 0.02);
    };

    // Kick808: long, boomy, subby - classic hip-hop
    SYNTHS['kick808'] = function(t, note, params) {
      const pitch = params[0] || 0;
      const f = pitch > 0 ? midiHz(pitch) : 45;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(f * 3, t);
      osc.frequency.exponentialRampToValueAtTime(f, t + 0.1);
      gain.gain.setValueAtTime(0.8, t);
      gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
      osc.connect(gain).connect(getAudioDest());
      osc.start(t); osc.stop(t + 0.55);
      // Sub layer
      const sub = audioCtx.createOscillator();
      const sg = audioCtx.createGain();
      sub.type = 'sine';
      sub.frequency.value = f * 0.5;
      sg.gain.setValueAtTime(0.5, t);
      sg.gain.exponentialRampToValueAtTime(0.01, t + 0.6);
      sub.connect(sg).connect(getAudioDest());
      sub.start(t); sub.stop(t + 0.65);
    };

    // Clap: layered noise bursts
    SYNTHS['clap'] = function(t, note, params) {
      for (let i = 0; i < 3; i++) {
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.02, audioCtx.sampleRate);
        const d = buf.getChannelData(0);
        for (let j = 0; j < d.length; j++) d[j] = Math.random() * 2 - 1;
        const src = audioCtx.createBufferSource();
        const filt = audioCtx.createBiquadFilter();
        const gain = audioCtx.createGain();
        src.buffer = buf;
        filt.type = 'bandpass';
        filt.frequency.value = 1200;
        filt.Q.value = 2;
        gain.gain.setValueAtTime(0.5, t + i * 0.015);
        gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.015 + 0.1);
        src.connect(filt).connect(gain).connect(getAudioDest());
        src.start(t + i * 0.015);
      }
    };

    // Rimshot: short, snappy
    SYNTHS['rim'] = function(t, note, params) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(800, t);
      osc.frequency.exponentialRampToValueAtTime(300, t + 0.01);
      gain.gain.setValueAtTime(0.5, t);
      gain.gain.exponentialRampToValueAtTime(0.01, t + 0.03);
      osc.connect(gain).connect(getAudioDest());
      osc.start(t); osc.stop(t + 0.04);
    };

    // ============ FM SYNTH (XFM PACK) ============
    // 4-operator FM synthesis inspired by Yamaha DX7 / Sega Genesis
    // Algorithms define how operators modulate each other
    const FM_ALGORITHMS = [
      // Alg 0: [4→3→2→1]→out (classic FM stack)
      { carriers: [0], modulators: [[1,2,3], [2,3], [3], []] },
      // Alg 1: [4→3]→[2→1]→out (parallel stacks)
      { carriers: [0], modulators: [[1], [2,3], [3], []] },
      // Alg 2: [4,3,2]→1→out (3 modulators to carrier)
      { carriers: [0], modulators: [[1,2,3], [], [], []] },
      // Alg 3: [4→3→2, 4→1]→out (split feedback)
      { carriers: [0,1], modulators: [[3], [2,3], [3], []] },
      // Alg 4: [4→3, 2→1]→out (dual stacks)
      { carriers: [0,2], modulators: [[1], [], [3], []] },
      // Alg 5: [4,3,2,1]→out (all carriers, additive)
      { carriers: [0,1,2,3], modulators: [[], [], [], []] },
      // Alg 6: [4→3→2→1, 4→1]→out (feedback ring)
      { carriers: [0], modulators: [[1,2,3], [2], [3], [0]] },
      // Alg 7: [4→2, 3→1]→out (cross modulation)
      { carriers: [0,1], modulators: [[2], [3], [], []] },
    ];

    SYNTHS['fm'] = function(t, note, params, adsr = {a:0.01, d:0.2, s:0.4, r:0.3}) {
      const f = noteToHz(note, 2);
      const algo = FM_ALGORITHMS[MEM[XFM.ALGORITHM] & 7];
      const dest = getAudioDest();

      // Create 4 operators
      const ops = [];
      const opGains = [];
      for (let i = 0; i < 4; i++) {
        const baseAddr = XFM.OP1_RATIO + i * 4;
        const ratio = 0.5 + (MEM[baseAddr] / 255) * 15.5;
        const level = MEM[baseAddr + 1] / 255;
        const wave = MEM[baseAddr + 3] & 3;
        const waveTypes = ['sine', 'sawtooth', 'square', 'triangle'];

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = waveTypes[wave];
        osc.frequency.value = f * ratio;

        // Operator envelope from XFM memory
        const envBase = XFM.OP1_A + i * 4;
        const a = (MEM[envBase] / 255) * 0.5;
        const d = (MEM[envBase + 1] / 255) * 0.5;
        const s = MEM[envBase + 2] / 255;
        const r = (MEM[envBase + 3] / 255) * 1.0;
        const totalTime = a + d + 0.1 + r;

        const peakVol = level;
        const sustainVol = peakVol * s;
        gain.gain.setValueAtTime(0.001, t);
        gain.gain.linearRampToValueAtTime(peakVol, t + a);
        gain.gain.linearRampToValueAtTime(Math.max(0.001, sustainVol), t + a + d);
        gain.gain.setValueAtTime(Math.max(0.001, sustainVol), t + a + d + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, t + totalTime);

        osc.connect(gain);
        ops.push(osc);
        opGains.push(gain);

        osc.start(t);
        osc.stop(t + totalTime + 0.05);
      }

      // Connect operators based on algorithm
      for (let i = 0; i < 4; i++) {
        const mods = algo.modulators[i];
        if (mods && mods.length > 0) {
          // This operator modulates others
          for (const modTarget of mods) {
            if (modTarget < 4) {
              // Modulate the frequency of target operator
              const modGain = audioCtx.createGain();
              modGain.gain.value = f * ((MEM[XFM.OP1_RATIO + i * 4 + 1] / 255) * 2);
              opGains[i].connect(modGain);
              modGain.connect(ops[modTarget].frequency);
            }
          }
        }
      }

      // Connect carriers to output
      for (const c of algo.carriers) {
        opGains[c].connect(dest);
      }
    };

    // Register FM as a lead synth option
    SYNTH_IDS.lead.push('fm');

    // ============ SID SYNTH (XSID PACK) ============
    // Commodore 64 SID 6581 inspired synthesis
    // Ring modulation, oscillator sync, multimode filter
    const XSID = {
      OSC1_WAVE:     0x1450,  // 0=tri, 1=saw, 2=pulse, 3=noise
      OSC1_DUTY:     0x1451,  // Pulse width 0-255
      OSC1_SYNC:     0x1452,  // Sync to OSC2 (bit 0)
      OSC1_RING:     0x1453,  // Ring mod with OSC2 (bit 0)
      OSC2_WAVE:     0x1454,
      OSC2_DUTY:     0x1455,
      OSC2_DETUNE:   0x1456,  // Detune cents (-128 to +127)
      OSC2_OCTAVE:   0x1457,  // Octave offset (-2 to +2, stored as 0-4)
      OSC3_WAVE:     0x1458,
      OSC3_DUTY:     0x1459,
      OSC3_DETUNE:   0x145A,
      OSC3_OCTAVE:   0x145B,
      FILTER_ROUTE:  0x145C,  // Which oscs hit filter (bits 0-2)
      FILTER_TYPE:   0x145D,  // 0=LP, 1=HP, 2=BP, 3=Notch
      FILTER_CUTOFF: 0x145E,  // 0-255
      FILTER_RESO:   0x145F,  // 0-255 (famous SID resonance!)
    };

    // Initialize XSID defaults
    function initXSIDDefaults() {
      MEM[XSID.OSC1_WAVE] = 2;     // Pulse
      MEM[XSID.OSC1_DUTY] = 128;   // 50% duty
      MEM[XSID.OSC2_WAVE] = 1;     // Saw
      MEM[XSID.OSC2_DETUNE] = 133; // +5 cents (128 = center)
      MEM[XSID.OSC2_OCTAVE] = 2;   // Same octave
      MEM[XSID.OSC3_WAVE] = 0;     // Triangle (sub)
      MEM[XSID.OSC3_OCTAVE] = 1;   // -1 octave
      MEM[XSID.FILTER_ROUTE] = 7;  // All through filter
      MEM[XSID.FILTER_TYPE] = 0;   // Lowpass
      MEM[XSID.FILTER_CUTOFF] = 200;
      MEM[XSID.FILTER_RESO] = 100;
    }

    // SID-style synth with 3 oscillators, ring mod, sync, filter
    SYNTHS['sid'] = function(t, note, params, adsr = {a:0.01, d:0.15, s:0.6, r:0.25}) {
      const baseF = noteToHz(note, 2);
      const dest = getAudioDest();
      const waveTypes = ['triangle', 'sawtooth', 'square', 'custom']; // custom = noise

      // Create filter (the famous SID filter!)
      const filter = audioCtx.createBiquadFilter();
      const filterTypes = ['lowpass', 'highpass', 'bandpass', 'notch'];
      filter.type = filterTypes[MEM[XSID.FILTER_TYPE] & 3];
      filter.frequency.value = 100 + (MEM[XSID.FILTER_CUTOFF] / 255) * 7900;
      // SID resonance is legendary - can self-oscillate
      filter.Q.value = 0.5 + (MEM[XSID.FILTER_RESO] / 255) * 25;
      filter.connect(dest);

      const peakVol = 0.2;
      const sustainVol = peakVol * adsr.s;
      const totalTime = adsr.a + adsr.d + 0.15 + adsr.r;

      // Create 3 oscillators
      const oscs = [];
      const gains = [];

      for (let i = 0; i < 3; i++) {
        const baseAddr = XSID.OSC1_WAVE + i * 4;
        const wave = MEM[baseAddr] & 3;
        const duty = MEM[baseAddr + 1] || 128;
        const detune = (MEM[baseAddr + 2] || 128) - 128; // -128 to +127 cents
        const octave = (MEM[baseAddr + 3] || 2) - 2;     // -2 to +2 octaves

        // Calculate frequency with octave and detune
        let f = baseF * Math.pow(2, octave);
        f *= Math.pow(2, detune / 1200); // cents to ratio

        let osc;
        if (wave === 3) {
          // Noise oscillator
          const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
          const d = buf.getChannelData(0);
          for (let j = 0; j < d.length; j++) d[j] = Math.random() * 2 - 1;
          osc = audioCtx.createBufferSource();
          osc.buffer = buf;
          osc.loop = true;
        } else {
          osc = audioCtx.createOscillator();
          osc.type = waveTypes[wave];
          osc.frequency.value = f;

          // Pulse width for square wave (fake it with phase offset)
          if (wave === 2 && duty !== 128) {
            // Create a second oscillator for PWM effect
            const pwmOsc = audioCtx.createOscillator();
            const pwmGain = audioCtx.createGain();
            pwmOsc.type = 'sawtooth';
            pwmOsc.frequency.value = f;
            // Invert and offset based on duty cycle
            pwmGain.gain.value = (duty - 128) / 255;
            pwmOsc.connect(pwmGain);
            const mixer = audioCtx.createGain();
            mixer.gain.value = 0.5;
            pwmGain.connect(mixer);
            pwmOsc.start(t);
            pwmOsc.stop(t + totalTime);
          }
        }

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.001, t);
        gain.gain.linearRampToValueAtTime(peakVol / 3, t + adsr.a);
        gain.gain.linearRampToValueAtTime(Math.max(0.001, sustainVol / 3), t + adsr.a + adsr.d);
        gain.gain.exponentialRampToValueAtTime(0.001, t + totalTime);

        oscs.push(osc);
        gains.push(gain);

        // Route through filter or direct based on FILTER_ROUTE
        const routeToFilter = (MEM[XSID.FILTER_ROUTE] >> i) & 1;
        if (wave !== 3) osc.connect(gain);
        else osc.connect(gain);

        if (routeToFilter) {
          gain.connect(filter);
        } else {
          gain.connect(dest);
        }

        osc.start(t);
        osc.stop(t + totalTime + 0.05);
      }

      // Ring modulation: OSC1 amplitude modulated by OSC2
      if (MEM[XSID.OSC1_RING] & 1) {
        // Ring mod = multiply two signals
        // In Web Audio, we use a gain node whose gain is modulated
        const ringMod = audioCtx.createGain();
        ringMod.gain.value = 0;
        // OSC2 modulates the gain of OSC1
        gains[1].connect(ringMod.gain);
        // Reconnect OSC1 through ring mod
        gains[0].disconnect();
        gains[0].connect(ringMod);
        const routeToFilter = MEM[XSID.FILTER_ROUTE] & 1;
        if (routeToFilter) {
          ringMod.connect(filter);
        } else {
          ringMod.connect(dest);
        }
      }

      // Hard sync: OSC1 synced to OSC2 (simplified - restart OSC1 at OSC2 frequency)
      if (MEM[XSID.OSC1_SYNC] & 1) {
        // True hard sync isn't possible in Web Audio without AudioWorklet
        // Fake it by adding harmonics
        if (oscs[0].type) {
          // Add extra harmonics to simulate sync "buzz"
          const syncOsc = audioCtx.createOscillator();
          const syncGain = audioCtx.createGain();
          const f2 = oscs[1].frequency ? oscs[1].frequency.value : baseF;
          syncOsc.type = 'sawtooth';
          syncOsc.frequency.value = f2 + (baseF % f2); // Residual frequency
          syncGain.gain.value = 0.15;
          syncGain.gain.exponentialRampToValueAtTime(0.001, t + totalTime * 0.5);
          syncOsc.connect(syncGain);
          const routeToFilter = MEM[XSID.FILTER_ROUTE] & 1;
          if (routeToFilter) {
            syncGain.connect(filter);
          } else {
            syncGain.connect(dest);
          }
          syncOsc.start(t);
          syncOsc.stop(t + totalTime);
        }
      }
    };

    // Register SID as synth options
    SYNTH_IDS.lead.push('sid');
    SYNTH_IDS.bass.push('sid');

    // Legacy wrappers - read synth selector from MEMORY (MTMC-16 style!)
    function playKick(t, p) { SYNTHS[getVoiceSynth('kick')](t, 0, [p]); }
    function playSnare(t, tone, snap) { SYNTHS[getVoiceSynth('snare')](t, 0, [tone, snap]); }
    function playLead(t, note, arp) { SYNTHS[getVoiceSynth('lead')](t, note, [arp]); }
    function playBass(t, note, fm, filt) { SYNTHS[getVoiceSynth('bass')](t, note, [fm, filt]); }
    function playNoise(t, y, type) { SYNTHS[getVoiceSynth('noise')](t, 0, [y, type]); }
    // ============ SEQUENCER ============
    function shouldTrigger(voice, stepIdx) {
      const v = VOICES[voice];
      const prob = MEM[v.prob + stepIdx];
      // 0 or undefined = 100% (default), 1-100 = that percentage
      if (prob === 0 || prob === undefined) return true;
      return Math.random() * 100 < prob;
    }

    function getRatchets(voice, stepIdx) {
      const v = VOICES[voice];
      const r = MEM[v.ratch + stepIdx];
      // 0 or undefined = 1 (single hit), 2-8 = that many hits
      return (r && r > 1) ? Math.min(r, 8) : 1;
    }

    function tick() {
      const t = nextTime;
      const baseStep = (60 / tempo) / 4;

      // Update RAM monitor - show current step address being read
      CPU.pc = 0x1000 + step;
      BUS.lastAddr = CPU.pc;
      BUS.lastOp = 'READ';
      BUS.bytesRead += 5; // Reading 5 voice gates
      CPU.cycles++;

      // Kick with prob/ratchet
      if (MEM[0x1000 + step] && shouldTrigger('kick', step)) {
        const ratchets = getRatchets('kick', step);
        const ratchetTime = baseStep / ratchets;
        for (let r = 0; r < ratchets; r++) {
          playKick(t + r * ratchetTime * 0.9, MEM[0x1010 + step]);
        }
      }
      // Snare with prob/ratchet
      if (MEM[0x1020 + step] && shouldTrigger('snare', step)) {
        const ratchets = getRatchets('snare', step);
        const ratchetTime = baseStep / ratchets;
        for (let r = 0; r < ratchets; r++) {
          playSnare(t + r * ratchetTime * 0.9, MEM[0x1030 + step], MEM[0x1040 + step]);
        }
      }
      // Lead with prob/ratchet
      if (MEM[0x1100 + step] && shouldTrigger('lead', step)) {
        const ratchets = getRatchets('lead', step);
        const ratchetTime = baseStep / ratchets;
        for (let r = 0; r < ratchets; r++) {
          playLead(t + r * ratchetTime * 0.9, MEM[0x1100 + step], MEM[0x1110 + step]);
        }
      }
      // Bass with prob/ratchet
      if (MEM[0x1200 + step] && shouldTrigger('bass', step)) {
        const ratchets = getRatchets('bass', step);
        const ratchetTime = baseStep / ratchets;
        for (let r = 0; r < ratchets; r++) {
          playBass(t + r * ratchetTime * 0.9, MEM[0x1200 + step], MEM[0x1210 + step], MEM[0x1220 + step]);
        }
      }
      // Noise with prob/ratchet
      if (MEM[0x1300 + step] && shouldTrigger('noise', step)) {
        const ratchets = getRatchets('noise', step);
        const ratchetTime = baseStep / ratchets;
        for (let r = 0; r < ratchets; r++) {
          playNoise(t + r * ratchetTime * 0.9, MEM[0x1310 + step], MEM[0x1320 + step]);
        }
      }

      // Advanced features
      LFO.tick();
      evolveStep();

      // Visuals (skip if game mode is active - games handle their own LCD)
      setTimeout(() => {
        measurePerf();
        syncGridsFromMem();
        updateMemDisplay();
        drawLCD();
      }, (t - audioCtx.currentTime) * 1000);
      // Apply swing: delay odd steps, keep total pair time constant
      const swingOffset = (swing / 100) * baseStep * 0.5; // 0-50% of step

      if (step % 2 === 0) {
        // Even step → next odd step is delayed, so longer gap
        nextTime += baseStep + swingOffset;
      } else {
        // Odd step → was delayed, shorter gap to next even
        nextTime += baseStep - swingOffset;
      }
      step = (step + 1) % 16;
      totalSteps++;
      if (step === 0) {
        currentBar++;
        TIMELINE.updateDisplay();
      }
    }

    function scheduler() {
      while (nextTime < audioCtx.currentTime + 0.1) tick();
      timer = setTimeout(scheduler, 25);
    }

    function togglePlay() {
      if (!audioCtx) initAudio();

      isPlaying = !isPlaying;
      const btn = document.getElementById('btn-play');

      if (isPlaying) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        step = 0;
        currentBar = 0;
        totalSteps = 0;
        nextTime = audioCtx.currentTime;
        scheduler();
        btn.textContent = '■ STOP';
        btn.classList.add('playing');
        TIMELINE.updateDisplay();

        // Update RAM monitor - CPU is running
        CPU.state = 'RUN';
        CPU.pc = 0x1000; // Start of audio MMIO
        BUS.active = true;
        updateBusStatus();

        // Auto-snapshot at play start
        if (timelineRecording && TIMELINE.events.length === 0) {
          TIMELINE.snapshot('START');
        }
      } else {
        clearTimeout(timer);
        btn.textContent = '▶ PLAY';
        btn.classList.remove('playing');

        // Update RAM monitor - CPU halted
        CPU.state = 'HALT';
        BUS.active = false;
        BUS.lastOp = 'IDLE';
        updateBusStatus();
      }
    }

    // ============ THEORY TOOLTIP ============
    let theoryTimeout = null;
    function showTheory(genre, text) {
      // Remove existing toast
      const existing = document.querySelector('.theory-toast');
      if (existing) existing.remove();
      if (theoryTimeout) clearTimeout(theoryTimeout);

      const toast = document.createElement('div');
      toast.className = 'theory-toast';
      toast.innerHTML = `
        <div class="theory-genre">${genre}</div>
        <div class="theory-text">${text}</div>
      `;
      document.body.appendChild(toast);

      // Auto-dismiss after 6 seconds
      theoryTimeout = setTimeout(() => {
        toast.style.animation = 'fadeOut 0.3s ease forwards';
        setTimeout(() => toast.remove(), 300);
      }, 6000);

      // Click to dismiss
      toast.addEventListener('click', () => {
        toast.remove();
        if (theoryTimeout) clearTimeout(theoryTimeout);
      });
    }

    // ============ VISUALS ============
    function updateMemDisplay() {
      if (PANIC.active) return;  // Don't update during PANIC

      [
        [0x1000, 16],
        [0x1020, 16],
        [0x1100, 16],
        [0x1200, 16],
        [0x1300, 16]
      ].forEach(([base]) => {
        for (let i = 0; i < 16; i++) {
          const addr = base + i;
          const el = document.getElementById(`m${base.toString(16)}_${i}`);
          if (el) {
            // Base classes
            let classes = 'mem-cell';
            if (MEM[addr]) classes += ' on';
            if (i === step && isPlaying) classes += ' play';

            // Heat map: convert 0-255 heat to 1-8 level
            const heat = MEM_HEAT[addr];
            if (heat > 0) {
              const level = Math.ceil(heat / 32);  // 0-255 → 1-8
              classes += ` heat-${level}`;
            }

            el.className = classes;
            el.innerText = MEM[addr] || '';
          }
        }
      });

      // Update bus status display
      updateBusStatus();
      updateHexDump();
    }

    function updateBusStatus() {
      const addrEl = document.getElementById('bus-addr');
      const stateEl = document.getElementById('cpu-state');
      const cyclesEl = document.getElementById('cpu-cycles');
      const rwEl = document.getElementById('bus-rw');
      const indicator = document.getElementById('bus-indicator');

      if (addrEl) addrEl.innerText = '$' + BUS.lastAddr.toString(16).toUpperCase().padStart(4, '0');
      if (stateEl) {
        stateEl.innerText = CPU.state;
        stateEl.className = 'cpu-state ' + CPU.state.toLowerCase();
      }
      if (cyclesEl) cyclesEl.innerText = 'CYC:' + CPU.cycles;
      if (rwEl) rwEl.innerText = `R:${BUS.bytesRead} W:${BUS.bytesWritten}`;

      // Flash bus LED based on operation
      if (indicator) {
        if (isPlaying && BUS.lastOp !== 'IDLE') {
          indicator.className = 'bus-led ' + BUS.lastOp.toLowerCase();
        } else if (!isPlaying) {
          indicator.className = 'bus-led idle';
        }
      }
    }

    function toggleTrace() {
      DEBUG.enabled = !DEBUG.enabled;
      const log = document.getElementById('trace-log');
      log.classList.toggle('open', DEBUG.enabled);
      document.getElementById('status').innerText = DEBUG.enabled ? 'TRACE ON' : 'TRACE OFF';
    }

    function updateTraceLog() {
      if (!DEBUG.enabled) return;
      const log = document.getElementById('trace-log');
      log.innerHTML = DEBUG.traceLog.slice(0, 20).map(e =>
        `<div class="trace-entry"><span class="op-${e.op.toLowerCase()}">${e.op}</span> $${e.addr.toString(16).padStart(4,'0')} = ${e.val} (was ${e.prev}) @${e.cycle}</div>`
      ).join('');
    }

    function testPanic() {
      // Trigger a test panic for demonstration
      triggerPanic(0xFF, 'TEST PANIC TRIGGERED', 0xDEAD);
    }

    // Heat decay timer - runs every 100ms
    let heatDecayTimer = null;
    function startHeatDecay() {
      if (heatDecayTimer) return;
      heatDecayTimer = setInterval(() => {
        decayHeat();
        if (DEBUG.enabled) updateTraceLog();
      }, 100);
    }

    function drawLCD() {
      // Layout: 10px header, 117px grid (13 rows × 9px), 17px status bar
      const HDR_H = 10, GRID_Y = 10, GRID_H = 117, STATUS_Y = 127;
      const CELL_W = 10, CELL_H = 9, COLS = 16, ROWS = 13;

      // Clear
      ctx.fillStyle = C[0];
      ctx.fillRect(0, 0, 160, 144);

      // Column headers (0-F)
      ctx.fillStyle = C[3];
      ctx.font = '8px monospace';
      for (let c = 0; c < COLS; c++) {
        ctx.fillText(c.toString(16).toUpperCase(), c * CELL_W + 2, 8);
      }

      // Header separator line
      ctx.strokeStyle = C[2];
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, GRID_Y);
      ctx.lineTo(160, GRID_Y);
      ctx.stroke();

      // Grid lines
      ctx.strokeStyle = C[1];
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= 160; x += CELL_W) {
        ctx.beginPath();
        ctx.moveTo(x, GRID_Y);
        ctx.lineTo(x, GRID_Y + GRID_H);
        ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
        ctx.beginPath();
        ctx.moveTo(0, GRID_Y + y * CELL_H);
        ctx.lineTo(160, GRID_Y + y * CELL_H);
        ctx.stroke();
      }

      // Draw active notes as pixels
      for (let s = 0; s < 16; s++) {
        const x = s * CELL_W;
        // Lead
        if (MEM[0x1100 + s]) {
          const row = Math.min(12, Math.max(0, 12 - (MEM[0x1100 + s] - 48)));
          ctx.fillStyle = C[2];
          ctx.fillRect(x + 1, GRID_Y + row * CELL_H + 1, CELL_W - 2, CELL_H - 2);
        }
        // Bass
        if (MEM[0x1200 + s]) {
          const row = Math.min(12, Math.max(0, 12 - (MEM[0x1200 + s] - 36) + 4));
          ctx.fillStyle = C[3];
          ctx.fillRect(x + 1, GRID_Y + row * CELL_H + 1, CELL_W - 2, CELL_H - 2);
        }
        // Noise
        if (MEM[0x1300 + s]) {
          const row = Math.min(12, MEM[0x1310 + s]);
          ctx.fillStyle = MEM[0x1320 + s] ? C[3] : C[2];
          ctx.fillRect(x + 2, GRID_Y + row * CELL_H + 2, CELL_W - 4, CELL_H - 4);
        }
      }

      // Playhead
      ctx.fillStyle = C[3];
      ctx.globalAlpha = 0.7;
      ctx.fillRect(step * CELL_W, GRID_Y, 2, GRID_H);
      ctx.globalAlpha = 1.0;

      // Status bar separator
      ctx.strokeStyle = C[2];
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, STATUS_Y);
      ctx.lineTo(160, STATUS_Y);
      ctx.stroke();

      // Status bar background (subtle)
      ctx.fillStyle = C[1];
      ctx.globalAlpha = 0.3;
      ctx.fillRect(0, STATUS_Y, 160, 17);
      ctx.globalAlpha = 1.0;

      // Status text
      ctx.fillStyle = C[3];
      ctx.font = '7px monospace';
      ctx.fillText(`${step.toString(16).toUpperCase()}`, 4, STATUS_Y + 11);
      ctx.fillText(`${tempo}BPM`, 20, STATUS_Y + 11);

      // Active voices count
      let voices = 0;
      if (MEM[0x1000 + step]) voices++;
      if (MEM[0x1020 + step]) voices++;
      if (MEM[0x1100 + step]) voices++;
      if (MEM[0x1200 + step]) voices++;
      if (MEM[0x1300 + step]) voices++;
      ctx.fillText(`V${voices}`, 60, STATUS_Y + 11);

      // Scale
      ctx.fillStyle = C[2];
      ctx.fillText(currentScale.name.substring(0, 4).toUpperCase(), 82, STATUS_Y + 11);

      // Mode indicators
      let modes = '';
      if (evolveActive) modes += 'E';
      if (lfoActive) modes += 'L';
      if (modes) {
        ctx.fillStyle = '#ff0055';
        ctx.fillText(modes, 115, STATUS_Y + 11);
      }

      // Swing indicator
      if (swing > 0) {
        ctx.fillStyle = C[2];
        ctx.fillText(`SW${swing}`, 135, STATUS_Y + 11);
      }
    }

    // ============ IMPORT/EXPORT ============
    let hexVisible = false;

    function exportData() {
      // Export all scenes as JSON
      const data = {
        version: '1010seq-v1',
        tempo: tempo,
        swing: swing,
        currentScene: currentScene,
        scenes: SCENES.map((s, i) => ({
          name: String.fromCharCode(65 + i),
          data: Array.from(s)
        }))
      };
      const json = JSON.stringify(data, null, 2);

      // Download as file
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `1010seq_${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);

      // Also copy to clipboard
      navigator.clipboard.writeText(json).then(() => {
        document.getElementById('status').innerText = 'EXPORTED FILE + CLIPBOARD';
      });

      // Log compact DSL for teaching
      console.log('=== $1010 EXPORT ===');
      console.log('');
      console.log('=== DSL (Scene ' + String.fromCharCode(65 + currentScene) + ') ===');
      console.log('KICK:  ', Array.from(MEM.slice(0x1000, 0x1010)).join(','));
      console.log('SNARE: ', Array.from(MEM.slice(0x1020, 0x1030)).join(','));
      console.log('LEAD:  ', Array.from(MEM.slice(0x1100, 0x1110)).join(','));
      console.log('BASS:  ', Array.from(MEM.slice(0x1200, 0x1210)).join(','));
      console.log('NOISE: ', Array.from(MEM.slice(0x1300, 0x1310)).join(','));

      return data;
    }

    // ============ MTMC-16 ASSEMBLY COMPILER ============
    function exportASM() {
      const title = document.getElementById('tl-title')?.value || 'Untitled';
      const date = new Date().toISOString().split('T')[0];

      // Helper to format array as assembly data
      const dataLine = (arr) => arr.map(v => v.toString()).join(' ');

      // Helper to create pattern string notation
      const patternStr = (arr, melodic = false) => {
        return arr.map(v => {
          if (v === 0) return '.';
          if (melodic) {
            const notes = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
            const oct = Math.floor(v / 12) - 1;
            const note = notes[v % 12];
            return note + oct;
          }
          return 'x';
        }).join('');
      };

      // Get current patterns
      const kick = Array.from(MEM.slice(0x1000, 0x1010));
      const kickPitch = Array.from(MEM.slice(0x1010, 0x1020));
      const snare = Array.from(MEM.slice(0x1020, 0x1030));
      const snareTone = Array.from(MEM.slice(0x1030, 0x1040));
      const snareSnap = Array.from(MEM.slice(0x1040, 0x1050));
      const lead = Array.from(MEM.slice(0x1100, 0x1110));
      const leadArp = Array.from(MEM.slice(0x1110, 0x1120));
      const bass = Array.from(MEM.slice(0x1200, 0x1210));
      const bassFm = Array.from(MEM.slice(0x1210, 0x1220));
      const bassFilt = Array.from(MEM.slice(0x1220, 0x1230));
      const noise = Array.from(MEM.slice(0x1300, 0x1310));
      const noiseDecay = Array.from(MEM.slice(0x1310, 0x1320));
      const noiseType = Array.from(MEM.slice(0x1320, 0x1330));

      const asm = `; ${title}.asm
; Generated by $1010 SEQUENCER for MTMC-16
; Date: ${date}
; Tempo: ${tempo} BPM | Swing: ${swing}%
;
; Pattern notation:
;   KICK:  ${patternStr(kick)}
;   SNARE: ${patternStr(snare)}
;   LEAD:  ${patternStr(lead, true)}
;   BASS:  ${patternStr(bass, true)}
;   NOISE: ${patternStr(noise)}
;
; Requires: MTMC-16 Audio Coprocessor ($1000-$15FF)
; See: MTMC16_AUDIO_SPEC.md

.data
  ; === VOICE PATTERNS (16 steps each) ===

  ; KICK ($1000)
  kick_gate:  ${dataLine(kick)}
  kick_pitch: ${dataLine(kickPitch)}

  ; SNARE ($1020)
  snare_gate: ${dataLine(snare)}
  snare_tone: ${dataLine(snareTone)}
  snare_snap: ${dataLine(snareSnap)}

  ; LEAD ($1100)
  lead_gate:  ${dataLine(lead)}
  lead_arp:   ${dataLine(leadArp)}

  ; BASS ($1200)
  bass_gate:  ${dataLine(bass)}
  bass_fm:    ${dataLine(bassFm)}
  bass_filt:  ${dataLine(bassFilt)}

  ; NOISE ($1300)
  noise_gate:  ${dataLine(noise)}
  noise_decay: ${dataLine(noiseDecay)}
  noise_type:  ${dataLine(noiseType)}

  ; Strings
  title_str: "${title}"
  ready_str: "READY - Press A to play, B to stop"

.text
; ============================================
; MAIN ENTRY POINT
; ============================================
main:
  jal audio_init          ; Initialize audio coprocessor
  jal load_patterns       ; Load patterns to audio memory
  jal display_init        ; Initialize display

main_loop:
  sys joystick            ; Read controller
  mov t0 rv

  ; A button (bit 0) = Start/toggle playback
  mov t1 t0
  andi t1 1
  jz check_b
  jal seq_toggle
  li a0 100
  sys sleep               ; Debounce

check_b:
  ; B button (bit 1) = Stop
  mov t1 t0
  andi t1 2
  jz check_dpad
  jal seq_stop

check_dpad:
  ; D-pad could control tempo, scene, etc.
  ; (extend as needed)

  ; Update display
  jal display_update

  j main_loop

; ============================================
; AUDIO INITIALIZATION
; ============================================
audio_init:
  push ra

  ; Set tempo (${tempo} BPM)
  li t0 ${tempo}
  sb t0 $1501             ; SEQ_TEMPO

  ; Set swing (${swing}%)
  li t0 ${swing}
  sb t0 $1503             ; SEQ_SWING

  ; Scene 0
  li t0 0
  sb t0 $1504             ; SEQ_SCENE

  pop ra
  ret

; ============================================
; LOAD PATTERNS TO AUDIO MEMORY
; ============================================
load_patterns:
  push ra

  ; KICK gate pattern -> $1000
  la a0 kick_gate
  li a1 $1000
  li a2 16
  sys memcopy

  ; KICK pitch -> $1010
  la a0 kick_pitch
  li a1 $1010
  li a2 16
  sys memcopy

  ; SNARE gate -> $1020
  la a0 snare_gate
  li a1 $1020
  li a2 16
  sys memcopy

  ; SNARE tone -> $1030
  la a0 snare_tone
  li a1 $1030
  li a2 16
  sys memcopy

  ; SNARE snap -> $1040
  la a0 snare_snap
  li a1 $1040
  li a2 16
  sys memcopy

  ; LEAD gate -> $1100
  la a0 lead_gate
  li a1 $1100
  li a2 16
  sys memcopy

  ; LEAD arp -> $1110
  la a0 lead_arp
  li a1 $1110
  li a2 16
  sys memcopy

  ; BASS gate -> $1200
  la a0 bass_gate
  li a1 $1200
  li a2 16
  sys memcopy

  ; BASS fm -> $1210
  la a0 bass_fm
  li a1 $1210
  li a2 16
  sys memcopy

  ; BASS filter -> $1220
  la a0 bass_filt
  li a1 $1220
  li a2 16
  sys memcopy

  ; NOISE gate -> $1300
  la a0 noise_gate
  li a1 $1300
  li a2 16
  sys memcopy

  ; NOISE decay -> $1310
  la a0 noise_decay
  li a1 $1310
  li a2 16
  sys memcopy

  ; NOISE type -> $1320
  la a0 noise_type
  li a1 $1320
  li a2 16
  sys memcopy

  pop ra
  ret

; ============================================
; SEQUENCER CONTROL
; ============================================
seq_start:
  push ra
  li t0 3                 ; bits: loop=1, play=1
  sb t0 $1500             ; SEQ_CTRL
  pop ra
  ret

seq_stop:
  push ra
  li t0 0
  sb t0 $1500             ; SEQ_CTRL
  pop ra
  ret

seq_toggle:
  push ra
  lb t0 $1500             ; Read current state
  xori t0 1               ; Toggle play bit
  sb t0 $1500
  pop ra
  ret

; ============================================
; DISPLAY (160x144, 4-color)
; ============================================
display_init:
  push ra
  sys fbreset

  ; Draw title
  ; (Could use drawimg or custom font)

  sys fbflush
  pop ra
  ret

display_update:
  push ra

  ; Read current step
  lb t0 $1502             ; SEQ_STEP

  ; Draw step indicator (16 columns)
  ; Clear previous, highlight current
  sys fbreset

  ; Draw 16-step grid
  li t1 0                 ; Column counter
draw_grid:
  ; Calculate X position: t1 * 10
  mov a0 t1
  li t2 10
  mul a0 t2

  ; Draw column (height based on voices active)
  li a1 80                ; Y position
  li a2 8                 ; Width
  li a3 40                ; Height

  ; Highlight current step
  eq t1 t0
  jz not_current
  li a0 2                 ; Brighter color
  sys scolor
  j draw_col
not_current:
  li a0 1
  sys scolor

draw_col:
  mov a0 t1
  li t2 10
  mul a0 t2
  sys fbrect

  inc t1
  lti t1 16
  jnz draw_grid

  sys fbflush
  pop ra
  ret

; ============================================
; END
; ============================================
`;

      // Download
      const blob = new Blob([asm], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.asm`;
      a.click();
      URL.revokeObjectURL(url);

      // Copy to clipboard
      navigator.clipboard.writeText(asm).then(() => {
        document.getElementById('status').innerText = 'EXPORTED MTMC-16 ASSEMBLY';
      });

      console.log('=== MTMC-16 ASM ===');
      console.log(asm);

      return asm;
    }

    // ============ TOOLCHAIN COMPILER ============
    let lastCompiledOutput = '';
    let lastCompiledTarget = 'mtmc16';

    function getDSLFromState() {
      // Generate DSL from current memory state
      const title = document.getElementById('tl-title')?.value || 'Untitled';

      const patternStr = (arr, melodic = false) => {
        return arr.map(v => {
          if (v === 0) return '.';
          if (melodic) {
            const notes = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
            const oct = Math.floor(v / 12) - 1;
            return notes[v % 12] + oct;
          }
          return 'x';
        }).join('');
      };

      const kick = Array.from(MEM.slice(0x1000, 0x1010));
      const snare = Array.from(MEM.slice(0x1020, 0x1030));
      const lead = Array.from(MEM.slice(0x1100, 0x1110));
      const bass = Array.from(MEM.slice(0x1200, 0x1210));
      const noise = Array.from(MEM.slice(0x1300, 0x1310));

      return `$1010 SONG v1
@title "${title}"
@tempo ${tempo}
@swing ${swing}

# Pattern definitions
@pattern p_kick "${patternStr(kick)}"
@pattern p_snare "${patternStr(snare)}"
@pattern p_lead "${patternStr(lead, true)}"
@pattern p_bass "${patternStr(bass, true)}"
@pattern p_noise "${patternStr(noise)}"

# Scene
@scene a
  kick: p_kick
  snare: p_snare
  lead: p_lead
  bass: p_bass
  noise: p_noise

@play a loop
`;
    }

    function compileAndShow() {
      const target = document.getElementById('tc-target').value;
      const dsl = getDSLFromState();
      const statusEl = document.getElementById('tc-status');
      const outputEl = document.getElementById('tc-output');

      // Check if compiler is loaded
      if (typeof Compiler1010 === 'undefined') {
        statusEl.innerHTML = '<span style="color:#f80;">Loading compiler...</span>';
        // Try to load compiler dynamically
        const script = document.createElement('script');
        script.src = '1010compiler.js';
        script.onload = () => compileAndShow();
        script.onerror = () => {
          statusEl.innerHTML = '<span style="color:#f00;">Compiler not found. Using built-in fallback.</span>';
          // Fallback: use built-in exportASM for MTMC target
          if (target === 'mtmc16' || target === 'asm') {
            const asm = exportASM();
            outputEl.value = asm;
            lastCompiledOutput = asm;
            lastCompiledTarget = target;
          } else {
            outputEl.value = '; Load 1010compiler.js for ' + target + ' target';
          }
        };
        document.head.appendChild(script);
        return;
      }

      // Compile
      const result = Compiler1010.compile(dsl, { target, title: document.getElementById('tl-title')?.value });

      if (result.errors.length > 0) {
        statusEl.innerHTML = `<span style="color:#f00;">ERRORS: ${result.errors.map(e => e.msg).join(', ')}</span>`;
        outputEl.value = result.errors.map(e => `Line ${e.line}: ${e.msg}`).join('\n');
        return;
      }

      let warnings = '';
      if (result.warnings.length > 0) {
        warnings = ` | ${result.warnings.length} warning(s)`;
      }

      statusEl.innerHTML = `<span style="color:#0f0;">COMPILED: ${target.toUpperCase()}</span>${warnings}`;
      outputEl.value = result.output;
      lastCompiledOutput = result.output;
      lastCompiledTarget = target;
    }

    function downloadCompiled() {
      if (!lastCompiledOutput) {
        document.getElementById('tc-status').innerHTML = '<span style="color:#f80;">Nothing compiled yet</span>';
        return;
      }

      const extensions = {
        mtmc16: '.asm',
        asm: '.asm',
        wasm: '.wat',
        wat: '.wat',
        c: '.c',
        rust: '.rs',
        rs: '.rs',
        hex: '.hex'
      };

      const ext = extensions[lastCompiledTarget] || '.txt';
      const title = document.getElementById('tl-title')?.value || 'output';
      const filename = title.replace(/[^a-z0-9]/gi, '_') + ext;

      const blob = new Blob([lastCompiledOutput], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);

      document.getElementById('tc-status').innerHTML = `<span style="color:#0f0;">SAVED: ${filename}</span>`;
    }

    function copyCompiled() {
      if (!lastCompiledOutput) {
        document.getElementById('tc-status').innerHTML = '<span style="color:#f80;">Nothing compiled yet</span>';
        return;
      }

      navigator.clipboard.writeText(lastCompiledOutput).then(() => {
        document.getElementById('tc-status').innerHTML = '<span style="color:#0f0;">COPIED TO CLIPBOARD</span>';
      });
    }

    function importData() {
      // Create hidden file input
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (evt) => {
          try {
            const data = JSON.parse(evt.target.result);
            if (data.version !== '1010seq-v1') throw new Error('Unknown format');

            tempo = data.tempo || 100;
            swing = data.swing || 0;
            document.getElementById('tempo-display').innerText = tempo;
            document.getElementById('swing-display').innerText = 'SW ' + swing + '%';

            data.scenes.forEach((scene, i) => {
              SCENES[i].set(scene.data);
            });

            currentScene = data.currentScene || 0;
            loadFromScene(currentScene);

            document.querySelectorAll('.scene-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.scene-btn[data-scene="${currentScene}"]`).classList.add('active');

            syncGridsFromMem();
            updateMemDisplay();
            drawLCD();
            document.getElementById('status').innerText = `IMPORTED: ${file.name}`;
          } catch (err) {
            document.getElementById('status').innerText = 'IMPORT ERROR: ' + err.message;
          }
        };
        reader.readAsText(file);
      };
      input.click();
    }

    // ============ WAV EXPORT ============
    async function exportWAV(bars = 4) {
      document.getElementById('status').innerText = 'RENDERING WAV...';

      const sampleRate = 44100;
      const stepTime = 60 / tempo / 4; // 16th note duration
      const totalSteps = bars * 16;
      const duration = totalSteps * stepTime + 2; // +2s for decay

      const offlineCtx = new OfflineAudioContext(2, sampleRate * duration, sampleRate);

      // Render each step
      for (let s = 0; s < totalSteps; s++) {
        const stepIdx = s % 16;
        const t = s * stepTime;

        // Kick
        if (MEM[0x1000 + stepIdx]) {
          renderKick(offlineCtx, t, MEM[0x1010 + stepIdx] || 36);
        }
        // Snare
        if (MEM[0x1020 + stepIdx]) {
          renderSnare(offlineCtx, t, MEM[0x1030 + stepIdx] || 180, MEM[0x1040 + stepIdx] || 100);
        }
        // Lead
        if (MEM[0x1100 + stepIdx]) {
          renderLead(offlineCtx, t, MEM[0x1100 + stepIdx]);
        }
        // Bass
        if (MEM[0x1200 + stepIdx]) {
          renderBass(offlineCtx, t, MEM[0x1200 + stepIdx], MEM[0x1220 + stepIdx] || 70);
        }
        // Noise
        if (MEM[0x1300 + stepIdx]) {
          renderNoise(offlineCtx, t, MEM[0x1310 + stepIdx] || 80);
        }
      }

      const buffer = await offlineCtx.startRendering();
      const wav = audioBufferToWav(buffer);
      const blob = new Blob([wav], { type: 'audio/wav' });

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `1010seq_${tempo}bpm_${bars}bars.wav`;
      a.click();
      URL.revokeObjectURL(url);

      document.getElementById('status').innerText = `EXPORTED ${bars} BARS @ ${tempo} BPM`;
    }

    // Export timeline as WAV with all snapshots rendered
    async function exportTimelineWAV() {
      if (Object.keys(TIMELINE.snapshots).length === 0) {
        document.getElementById('status').innerText = 'NO SNAPSHOTS - Take some first!';
        return;
      }

      document.getElementById('status').innerText = 'RENDERING TIMELINE WAV...';

      const sampleRate = 44100;
      const snapBars = Object.keys(TIMELINE.snapshots).map(Number).sort((a, b) => a - b);
      const totalBars = Math.max(...snapBars) + 4;

      // Calculate duration considering tempo changes
      let currentTempo = tempo;
      let totalDuration = 0;

      for (let bar = 0; bar < totalBars; bar++) {
        // Check for tempo change events at this bar
        const tempoEvent = TIMELINE.events.find(e => e.type === 'tempo' && e.bar === bar);
        if (tempoEvent) currentTempo = tempoEvent.data.tempo;
        totalDuration += (60 / currentTempo / 4) * 16; // 16 steps per bar
      }
      totalDuration += 2; // Decay tail

      const offlineCtx = new OfflineAudioContext(2, sampleRate * totalDuration, sampleRate);

      let currentPattern = null;
      let timeOffset = 0;
      currentTempo = tempo;

      for (let bar = 0; bar < totalBars; bar++) {
        // Check for tempo change
        const tempoEvent = TIMELINE.events.find(e => e.type === 'tempo' && e.bar === bar);
        if (tempoEvent) currentTempo = tempoEvent.data.tempo;

        // Check for snapshot
        if (TIMELINE.snapshots[bar]) {
          currentPattern = TIMELINE.snapshots[bar].mem;
        }

        const stepTime = 60 / currentTempo / 4;

        // Render this bar
        if (currentPattern) {
          for (let s = 0; s < 16; s++) {
            const t = timeOffset + s * stepTime;

            if (currentPattern[0 + s]) {
              renderKick(offlineCtx, t, currentPattern[0x10 + s] || 36);
            }
            if (currentPattern[0x20 + s]) {
              renderSnare(offlineCtx, t, currentPattern[0x30 + s] || 180, currentPattern[0x40 + s] || 100);
            }
            if (currentPattern[0x100 + s]) {
              renderLead(offlineCtx, t, currentPattern[0x100 + s]);
            }
            if (currentPattern[0x200 + s]) {
              renderBass(offlineCtx, t, currentPattern[0x200 + s], currentPattern[0x220 + s] || 70);
            }
            if (currentPattern[0x300 + s]) {
              renderNoise(offlineCtx, t, currentPattern[0x310 + s] || 80);
            }
          }
        }

        timeOffset += stepTime * 16;
      }

      const buffer = await offlineCtx.startRendering();
      const wav = audioBufferToWav(buffer);
      const blob = new Blob([wav], { type: 'audio/wav' });

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `1010_timeline_${totalBars}bars.wav`;
      a.click();
      URL.revokeObjectURL(url);

      document.getElementById('status').innerText = `TIMELINE WAV: ${totalBars} BARS EXPORTED`;
    }

    // Offline render versions of synths
    function renderKick(ctx, t, pitch) {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      const f = pitch > 0 ? midiHz(pitch) : 60;
      osc.frequency.setValueAtTime(f * 4, t);
      osc.frequency.exponentialRampToValueAtTime(f, t + 0.08);
      gain.gain.setValueAtTime(0.7, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      osc.connect(gain).connect(ctx.destination);
      osc.start(t);
      osc.stop(t + 0.4);
    }

    function renderSnare(ctx, t, tone, snap) {
      const osc = ctx.createOscillator();
      const noise = ctx.createBufferSource();
      const noiseGain = ctx.createGain();
      const oscGain = ctx.createGain();
      const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      noise.buffer = noiseBuffer;
      osc.frequency.setValueAtTime(tone, t);
      oscGain.gain.setValueAtTime(0.5, t);
      oscGain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      noiseGain.gain.setValueAtTime((snap / 127) * 0.5, t);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      osc.connect(oscGain).connect(ctx.destination);
      noise.connect(noiseGain).connect(ctx.destination);
      osc.start(t); osc.stop(t + 0.15);
      noise.start(t); noise.stop(t + 0.2);
    }

    function renderLead(ctx, t, note) {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(midiHz(note), t);
      gain.gain.setValueAtTime(0.25, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      osc.connect(gain).connect(ctx.destination);
      osc.start(t);
      osc.stop(t + 0.2);
    }

    function renderBass(ctx, t, note, filt) {
      const osc = ctx.createOscillator();
      const filter = ctx.createBiquadFilter();
      const gain = ctx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(midiHz(note), t);
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(100 + filt * 20, t);
      gain.gain.setValueAtTime(0.4, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
      osc.connect(filter).connect(gain).connect(ctx.destination);
      osc.start(t);
      osc.stop(t + 0.3);
    }

    function renderNoise(ctx, t, decay) {
      const noise = ctx.createBufferSource();
      const gain = ctx.createGain();
      const d = 0.05 + (decay / 127) * 0.3;
      const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * d, ctx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      noise.buffer = noiseBuffer;
      gain.gain.setValueAtTime(0.3, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + d);
      noise.connect(gain).connect(ctx.destination);
      noise.start(t);
      noise.stop(t + d + 0.01);
    }

    // WAV encoder
    function audioBufferToWav(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16;
      const bytesPerSample = bitDepth / 8;
      const blockAlign = numChannels * bytesPerSample;
      const data = interleave(buffer);
      const dataSize = data.length * bytesPerSample;
      const headerSize = 44;
      const totalSize = headerSize + dataSize;

      const arrayBuffer = new ArrayBuffer(totalSize);
      const view = new DataView(arrayBuffer);

      // RIFF header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, totalSize - 8, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);
      writeString(view, 36, 'data');
      view.setUint32(40, dataSize, true);

      // Write samples
      let offset = 44;
      for (let i = 0; i < data.length; i++) {
        const sample = Math.max(-1, Math.min(1, data[i]));
        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
        offset += 2;
      }

      return arrayBuffer;
    }

    function interleave(buffer) {
      const length = buffer.length * buffer.numberOfChannels;
      const result = new Float32Array(length);
      const channels = [];
      for (let i = 0; i < buffer.numberOfChannels; i++) {
        channels.push(buffer.getChannelData(i));
      }
      let idx = 0;
      for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
          result[idx++] = channels[ch][i];
        }
      }
      return result;
    }

    function writeString(view, offset, str) {
      for (let i = 0; i < str.length; i++) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    }

    // ============ MIDI IMPORT ============
    function importMIDI() {
      document.getElementById('midi-file-input').click();
    }

    document.getElementById('midi-file-input').onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const buffer = await file.arrayBuffer();
      const data = new Uint8Array(buffer);

      try {
        const parsed = parseMIDI(data);
        document.getElementById('status').innerText = `IMPORTED: ${parsed.tracks} tracks, ${parsed.notes} notes`;
      } catch (err) {
        document.getElementById('status').innerText = 'MIDI PARSE ERROR: ' + err.message;
      }
      e.target.value = ''; // Reset for next import
    };

    // Simple MIDI parser - extracts note events
    function parseMIDI(data) {
      let pos = 0;

      // Read header
      const headerChunk = String.fromCharCode(...data.slice(0, 4));
      if (headerChunk !== 'MThd') throw new Error('Not a MIDI file');

      pos = 8; // Skip header chunk
      const format = (data[pos] << 8) | data[pos + 1];
      const numTracks = (data[pos + 2] << 8) | data[pos + 3];
      const division = (data[pos + 4] << 8) | data[pos + 5];
      pos = 14;

      const ticksPerStep = division / 4; // Assuming 16th notes
      const allNotes = [];

      // Parse each track
      for (let t = 0; t < numTracks; t++) {
        if (String.fromCharCode(...data.slice(pos, pos + 4)) !== 'MTrk') break;
        pos += 4;
        const trackLen = (data[pos] << 24) | (data[pos + 1] << 16) | (data[pos + 2] << 8) | data[pos + 3];
        pos += 4;

        const trackEnd = pos + trackLen;
        let tick = 0;
        let runningStatus = 0;

        while (pos < trackEnd) {
          // Read variable-length delta time
          let delta = 0;
          while (data[pos] & 0x80) {
            delta = (delta << 7) | (data[pos] & 0x7F);
            pos++;
          }
          delta = (delta << 7) | data[pos];
          pos++;
          tick += delta;

          // Read event
          let status = data[pos];
          if (status & 0x80) {
            runningStatus = status;
            pos++;
          } else {
            status = runningStatus;
          }

          const eventType = status & 0xF0;
          const channel = status & 0x0F;

          if (eventType === 0x90 && data[pos + 1] > 0) {
            // Note on
            const note = data[pos];
            const velocity = data[pos + 1];
            const step = Math.floor(tick / ticksPerStep) % 16;
            allNotes.push({ tick, step, note, velocity, channel });
            pos += 2;
          } else if (eventType === 0x80 || (eventType === 0x90 && data[pos + 1] === 0)) {
            // Note off
            pos += 2;
          } else if (eventType === 0xA0 || eventType === 0xB0 || eventType === 0xE0) {
            pos += 2;
          } else if (eventType === 0xC0 || eventType === 0xD0) {
            pos += 1;
          } else if (status === 0xFF) {
            // Meta event
            const metaType = data[pos];
            pos++;
            let len = 0;
            while (data[pos] & 0x80) {
              len = (len << 7) | (data[pos] & 0x7F);
              pos++;
            }
            len = (len << 7) | data[pos];
            pos++;
            pos += len;
          } else if (status === 0xF0 || status === 0xF7) {
            // SysEx
            let len = 0;
            while (data[pos] & 0x80) {
              len = (len << 7) | (data[pos] & 0x7F);
              pos++;
            }
            len = (len << 7) | data[pos];
            pos++;
            pos += len;
          }
        }
      }

      // Map notes to voices based on channel/pitch
      // Clear current pattern
      for (let i = 0; i < 16; i++) {
        MEM[0x1000 + i] = 0; MEM[0x1010 + i] = 0;
        MEM[0x1020 + i] = 0; MEM[0x1030 + i] = 0;
        MEM[0x1100 + i] = 0; MEM[0x1110 + i] = 0;
        MEM[0x1200 + i] = 0; MEM[0x1210 + i] = 0;
        MEM[0x1300 + i] = 0; MEM[0x1310 + i] = 0;
      }

      // Sort and apply notes
      allNotes.sort((a, b) => a.tick - b.tick);

      allNotes.forEach(n => {
        const step = n.step;
        if (n.channel === 9) {
          // Drums
          if (n.note === 36 || n.note === 35) {
            MEM[0x1000 + step] = 1;
            MEM[0x1010 + step] = 36;
          } else if (n.note === 38 || n.note === 40) {
            MEM[0x1020 + step] = 1;
            MEM[0x1030 + step] = 180;
          } else if (n.note >= 42 && n.note <= 46) {
            MEM[0x1300 + step] = 1;
            MEM[0x1310 + step] = 80;
          }
        } else if (n.channel === 0) {
          // Lead
          MEM[0x1100 + step] = n.note;
        } else if (n.channel === 1) {
          // Bass
          MEM[0x1200 + step] = n.note;
        }
      });

      saveToScene(currentScene);
      syncGridsFromMem();
      updateMemDisplay();

      return { tracks: numTracks, notes: allNotes.length };
    }

    // ============ MIDI EXPORT ============
    function exportMIDI(bars = 4) {
      const ticksPerBeat = 480;
      const ticksPerStep = ticksPerBeat / 4; // 16th notes

      // MIDI file structure
      const tracks = [];

      // Track 0: Tempo
      const tempoTrack = [];
      const microsecondsPerBeat = Math.round(60000000 / tempo);
      tempoTrack.push({ delta: 0, event: [0xFF, 0x51, 0x03,
        (microsecondsPerBeat >> 16) & 0xFF,
        (microsecondsPerBeat >> 8) & 0xFF,
        microsecondsPerBeat & 0xFF
      ]});
      tempoTrack.push({ delta: 0, event: [0xFF, 0x2F, 0x00] }); // End of track
      tracks.push(tempoTrack);

      // Voice tracks
      const voiceData = [
        { name: 'Kick', addr: 0x1000, noteAddr: 0x1010, ch: 9, defaultNote: 36 },
        { name: 'Snare', addr: 0x1020, noteAddr: 0x1030, ch: 9, defaultNote: 38 },
        { name: 'Lead', addr: 0x1100, noteAddr: 0x1100, ch: 0, defaultNote: 60 },
        { name: 'Bass', addr: 0x1200, noteAddr: 0x1200, ch: 1, defaultNote: 36 },
        { name: 'Noise', addr: 0x1300, noteAddr: 0x1310, ch: 9, defaultNote: 42 }
      ];

      voiceData.forEach(v => {
        const track = [];
        // Track name
        const nameBytes = Array.from(v.name).map(c => c.charCodeAt(0));
        track.push({ delta: 0, event: [0xFF, 0x03, nameBytes.length, ...nameBytes] });

        let lastTick = 0;
        for (let bar = 0; bar < bars; bar++) {
          for (let step = 0; step < 16; step++) {
            if (MEM[v.addr + step]) {
              const tick = (bar * 16 + step) * ticksPerStep;
              const note = MEM[v.noteAddr + step] || v.defaultNote;
              const velocity = 100;
              const duration = ticksPerStep - 10;

              // Note on
              track.push({ delta: tick - lastTick, event: [0x90 | v.ch, note, velocity] });
              lastTick = tick;

              // Note off
              track.push({ delta: duration, event: [0x80 | v.ch, note, 0] });
              lastTick = tick + duration;
            }
          }
        }

        track.push({ delta: 0, event: [0xFF, 0x2F, 0x00] }); // End of track
        tracks.push(track);
      });

      // Build MIDI file
      const midi = buildMIDIFile(tracks, ticksPerBeat);
      const blob = new Blob([midi], { type: 'audio/midi' });

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `1010seq_${tempo}bpm_${bars}bars.mid`;
      a.click();
      URL.revokeObjectURL(url);

      document.getElementById('status').innerText = `EXPORTED MIDI: ${bars} BARS`;
    }

    // Export timeline as MIDI with all automation baked in
    // Educational: This "compiles" your session DSL into a standard MIDI file
    function exportTimelineMIDI() {
      if (Object.keys(TIMELINE.snapshots).length === 0) {
        document.getElementById('status').innerText = 'NO SNAPSHOTS - Take some first!';
        return;
      }

      const ticksPerBeat = 480;
      const ticksPerStep = ticksPerBeat / 4;
      const ticksPerBar = ticksPerStep * 16;

      // Get sorted bar numbers with snapshots
      const snapBars = Object.keys(TIMELINE.snapshots).map(Number).sort((a, b) => a - b);
      const totalBars = Math.max(...snapBars) + 4; // Add 4 bars after last snapshot

      const tracks = [];

      // Track 0: Tempo changes from timeline
      const tempoTrack = [];
      let lastTempo = tempo;

      // Initial tempo
      const initMicros = Math.round(60000000 / tempo);
      tempoTrack.push({ delta: 0, event: [0xFF, 0x51, 0x03,
        (initMicros >> 16) & 0xFF, (initMicros >> 8) & 0xFF, initMicros & 0xFF
      ]});

      // Add tempo changes from events
      TIMELINE.events.filter(e => e.type === 'tempo').forEach(e => {
        const tick = e.bar * ticksPerBar;
        const micros = Math.round(60000000 / e.data.tempo);
        tempoTrack.push({ delta: tick, event: [0xFF, 0x51, 0x03,
          (micros >> 16) & 0xFF, (micros >> 8) & 0xFF, micros & 0xFF
        ]});
      });

      tempoTrack.push({ delta: totalBars * ticksPerBar, event: [0xFF, 0x2F, 0x00] });
      tracks.push(tempoTrack);

      // Voice tracks - render from snapshots
      const voiceData = [
        { name: 'Kick', addr: 0, noteAddr: 0x10, ch: 9, defaultNote: 36 },
        { name: 'Snare', addr: 0x20, noteAddr: 0x30, ch: 9, defaultNote: 38 },
        { name: 'Lead', addr: 0x100, noteAddr: 0x100, ch: 0, defaultNote: 60 },
        { name: 'Bass', addr: 0x200, noteAddr: 0x200, ch: 1, defaultNote: 36 },
        { name: 'Noise', addr: 0x300, noteAddr: 0x310, ch: 9, defaultNote: 42 }
      ];

      voiceData.forEach(v => {
        const track = [];
        const nameBytes = Array.from(v.name).map(c => c.charCodeAt(0));
        track.push({ delta: 0, event: [0xFF, 0x03, nameBytes.length, ...nameBytes] });

        let lastTick = 0;
        let currentPattern = null;

        for (let bar = 0; bar < totalBars; bar++) {
          // Check if there's a snapshot at this bar
          if (TIMELINE.snapshots[bar]) {
            currentPattern = TIMELINE.snapshots[bar].mem;
          }

          // Render this bar's pattern
          if (currentPattern) {
            for (let step = 0; step < 16; step++) {
              if (currentPattern[v.addr + step]) {
                const tick = bar * ticksPerBar + step * ticksPerStep;
                const note = currentPattern[v.noteAddr + step] || v.defaultNote;
                const velocity = 100;
                const duration = ticksPerStep - 10;

                track.push({ delta: tick - lastTick, event: [0x90 | v.ch, note, velocity] });
                lastTick = tick;
                track.push({ delta: duration, event: [0x80 | v.ch, note, 0] });
                lastTick = tick + duration;
              }
            }
          }
        }

        track.push({ delta: 0, event: [0xFF, 0x2F, 0x00] });
        tracks.push(track);
      });

      // Build and download
      const midi = buildMIDIFile(tracks, ticksPerBeat);
      const blob = new Blob([midi], { type: 'audio/midi' });

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `1010_timeline_${totalBars}bars.mid`;
      a.click();
      URL.revokeObjectURL(url);

      document.getElementById('status').innerText = `TIMELINE MIDI: ${totalBars} BARS EXPORTED`;
    }

    function buildMIDIFile(tracks, ticksPerBeat) {
      const chunks = [];

      // Header chunk
      const header = new Uint8Array(14);
      header.set([0x4D, 0x54, 0x68, 0x64]); // MThd
      header.set([0x00, 0x00, 0x00, 0x06], 4); // Chunk length
      header.set([0x00, 0x01], 8); // Format 1
      header.set([tracks.length >> 8, tracks.length & 0xFF], 10); // Num tracks
      header.set([ticksPerBeat >> 8, ticksPerBeat & 0xFF], 12); // Ticks per beat
      chunks.push(header);

      // Track chunks
      tracks.forEach(track => {
        const trackData = [];
        track.forEach(evt => {
          trackData.push(...varLength(evt.delta));
          trackData.push(...evt.event);
        });

        const chunk = new Uint8Array(8 + trackData.length);
        chunk.set([0x4D, 0x54, 0x72, 0x6B]); // MTrk
        const len = trackData.length;
        chunk.set([len >> 24, (len >> 16) & 0xFF, (len >> 8) & 0xFF, len & 0xFF], 4);
        chunk.set(trackData, 8);
        chunks.push(chunk);
      });

      // Combine chunks
      const totalLength = chunks.reduce((sum, c) => sum + c.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      chunks.forEach(c => {
        result.set(c, offset);
        offset += c.length;
      });

      return result;
    }

    function varLength(value) {
      if (value < 128) return [value];
      const bytes = [];
      bytes.push(value & 0x7F);
      value >>= 7;
      while (value > 0) {
        bytes.push((value & 0x7F) | 0x80);
        value >>= 7;
      }
      return bytes.reverse();
    }

    function toggleHex() {
      hexVisible = !hexVisible;
      const dump = document.getElementById('hex-dump');
      dump.style.display = hexVisible ? 'block' : 'none';
      if (hexVisible) updateHexDump();
    }

    function clearStorage() {
      localStorage.clear();
      sessionStorage.clear();

      // Reset MEM to defaults
      for (let i = 0; i < MEM.length; i++) MEM[i] = 0;

      // Reset tempo/swing to defaults
      tempo = 120;
      swing = 0;
      MEM[0x1501] = tempo;
      MEM[0x1503] = swing;
      document.getElementById('tempo-slider').value = tempo;
      document.getElementById('tempo-val').innerText = tempo;
      document.getElementById('swing-slider').value = swing;
      document.getElementById('swing-val').innerText = swing;

      // Clear loaded packs
      window.loadedPacks = [];
      renderPackStack();

      // Reset scene
      currentScene = 0;
      document.querySelectorAll('.scene-btn').forEach((btn, i) => {
        btn.classList.toggle('active', i === 0);
      });

      // Reset displays
      baseGenre = null;
      document.getElementById('genre-display').innerText = '---';

      // Reset tuning to defaults
      currentTuning = 0;
      a4Reference = 440;
      voiceDetune = [0, 0, 0, 0, 0];
      updateTuningDisplay();

      // Sync UI
      syncGridsFromMem();
      syncSlidersFromMem();
      updateMemDisplay();

      document.getElementById('status').innerText = 'ALL CLEARED - FRESH START!';
    }

    // Memory region labels for teaching
    const MEM_LABELS = {
      0x1000: 'KICK GATE (steps 0-15)',
      0x1010: 'KICK PITCH (MIDI note per step)',
      0x1020: 'SNARE GATE',
      0x1030: 'SNARE TONE (Hz)',
      0x1040: 'SNARE SNAP (decay)',
      0x1100: 'LEAD NOTE (MIDI)',
      0x1110: 'LEAD ARP (0=off, 1=maj, 2=min)',
      0x1200: 'BASS NOTE (MIDI)',
      0x1210: 'BASS FM (modulation depth)',
      0x1220: 'BASS FILTER (cutoff)',
      0x1300: 'NOISE GATE',
      0x1310: 'NOISE DECAY (1-15)',
      0x1320: 'NOISE TYPE (0=hat, 1=zap)',
    };

    function getByteInfo(addr) {
      const base = addr & 0xFFF0;
      const step = addr & 0x000F;
      const label = MEM_LABELS[base];
      if (!label) return `Address $${addr.toString(16).toUpperCase()}`;

      const val = MEM[addr];
      let info = `Step ${step}: `;

      if (label.includes('MIDI') || label.includes('NOTE')) {
        info += val ? `${midiToName(val)} (${val})` : 'OFF';
      } else if (label.includes('GATE')) {
        info += val ? 'ON' : 'OFF';
      } else {
        info += val;
      }

      return `${label}\n${info}`;
    }

    function updateHexDump() {
      if (!hexVisible) return;
      const dump = document.getElementById('hex-dump');
      dump.innerHTML = '';

      // Show key memory regions
      const regions = [
        [0x1000, 'KICK'],
        [0x1020, 'SNARE'],
        [0x1100, 'LEAD'],
        [0x1200, 'BASS'],
        [0x1300, 'NOISE'],
      ];

      regions.forEach(([base, name]) => {
        // Gate row
        const row1 = document.createElement('div');
        row1.className = 'hex-row';

        const addr1 = document.createElement('span');
        addr1.className = 'hex-addr';
        addr1.textContent = '$' + base.toString(16).toUpperCase();
        row1.appendChild(addr1);

        for (let i = 0; i < 16; i++) {
          const addr = base + i;
          const val = MEM[addr];
          const span = document.createElement('span');
          span.className = 'hex-byte' + (val ? ' nonzero' : '');
          span.textContent = val.toString(16).toUpperCase().padStart(2, '0');
          span.dataset.addr = addr;
          span.onclick = () => editHexByte(addr);
          span.onmouseenter = (e) => showHexTooltip(e, addr);
          span.onmouseleave = hideHexTooltip;
          row1.appendChild(span);
        }

        const label1 = document.createElement('span');
        label1.className = 'hex-label';
        label1.textContent = name + ' GATE';
        row1.appendChild(label1);
        dump.appendChild(row1);

        // Param row (if exists)
        const paramBase = base + 0x10;
        if (MEM_LABELS[paramBase]) {
          const row2 = document.createElement('div');
          row2.className = 'hex-row';

          const addr2 = document.createElement('span');
          addr2.className = 'hex-addr';
          addr2.textContent = '$' + paramBase.toString(16).toUpperCase();
          row2.appendChild(addr2);

          for (let i = 0; i < 16; i++) {
            const addr = paramBase + i;
            const val = MEM[addr];
            const span = document.createElement('span');
            span.className = 'hex-byte' + (val ? ' nonzero' : '');
            span.textContent = val.toString(16).toUpperCase().padStart(2, '0');
            span.dataset.addr = addr;
            span.onclick = () => editHexByte(addr);
            span.onmouseenter = (e) => showHexTooltip(e, addr);
            span.onmouseleave = hideHexTooltip;
            row2.appendChild(span);
          }

          const label2 = document.createElement('span');
          label2.className = 'hex-label';
          label2.textContent = MEM_LABELS[paramBase].split('(')[0].trim();
          row2.appendChild(label2);
          dump.appendChild(row2);
        }
      });
    }

    let tooltip = null;
    function showHexTooltip(e, addr) {
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.className = 'hex-tooltip';
        document.body.appendChild(tooltip);
      }
      tooltip.textContent = getByteInfo(addr);
      tooltip.style.left = (e.clientX + 10) + 'px';
      tooltip.style.top = (e.clientY + 10) + 'px';
      tooltip.style.display = 'block';
    }

    function hideHexTooltip() {
      if (tooltip) tooltip.style.display = 'none';
    }

    function editHexByte(addr) {
      const val = MEM[addr];
      const cell = event.target;

      // Create inline input
      const input = document.createElement('input');
      input.type = 'text';
      input.value = val;
      input.style.cssText = 'width:100%;height:100%;background:#111;color:var(--gb-0);border:1px solid var(--c-acc);text-align:center;font-family:inherit;font-size:inherit;padding:0;';
      input.maxLength = 3;

      const originalText = cell.innerText;
      cell.innerText = '';
      cell.appendChild(input);
      input.focus();
      input.select();

      function commit() {
        let newVal = input.value.trim().toLowerCase().startsWith('0x')
          ? parseInt(input.value, 16)
          : parseInt(input.value, 10);

        if (isNaN(newVal) || newVal < 0 || newVal > 255) {
          document.getElementById('status').innerText = 'INVALID (0-255)';
          cell.innerText = originalText;
          return;
        }

        MEM[addr] = newVal;
        saveToScene(currentScene);
        syncGridsFromMem();
        updateMemDisplay();
        drawLCD();
        document.getElementById('status').innerText = `$${addr.toString(16).toUpperCase()} = ${newVal}`;
      }

      input.onblur = commit;
      input.onkeydown = e => {
        if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
        if (e.key === 'Escape') { cell.innerText = originalText; }
      };
    }

    // ============ PERF MONITOR ============
    let lastTickTime = 0;
    let maxJitter = 0;
    function measurePerf() {
      if (!audioCtx) return;
      const now = performance.now();
      if (lastTickTime > 0) {
        const delta = now - lastTickTime;
        const expected = (60 / tempo / 4) * 1000; // ms per step
        const jitter = Math.abs(delta - expected);
        if (jitter > maxJitter) maxJitter = jitter;
        if (jitter > 50) {
          console.warn(`JITTER: ${jitter.toFixed(1)}ms (expected ${expected.toFixed(1)}ms)`);
        }
      }
      lastTickTime = now;
    }
    // ============ EVENTS ============
    document.getElementById('btn-play').onclick = togglePlay;
    document.getElementById('btn-mutate').onclick = mutateAll;
    document.getElementById('btn-tempo-up').onclick = () => {
      tempo = Math.min(200, tempo + 5);
      document.getElementById('tempo-display').innerText = tempo;
      TIMELINE.record('tempo', { tempo });
    };
    document.getElementById('btn-tempo-down').onclick = () => {
      tempo = Math.max(60, tempo - 5);
      document.getElementById('tempo-display').innerText = tempo;
      TIMELINE.record('tempo', { tempo });
    };
    document.getElementById('btn-swing-up').onclick = () => {
      swing = Math.min(75, swing + 5);
      document.getElementById('swing-display').innerText = 'SW ' + swing + '%';
      TIMELINE.record('swing', { swing });
    };
    document.getElementById('btn-swing-down').onclick = () => {
      swing = Math.max(0, swing - 5);
      document.getElementById('swing-display').innerText = 'SW ' + swing + '%';
      TIMELINE.record('swing', { swing });
    };

    // ============ TUNING CONTROLS ============
    document.getElementById('btn-tuning').onclick = () => {
      cycleTuning();
      TIMELINE.record('tuning', { mode: TUNING_MODES[currentTuning] });
    };
    document.getElementById('btn-a4-up').onclick = () => {
      setA4Reference(a4Reference + 1);
      document.getElementById('status').innerText = `A4 = ${a4Reference} Hz`;
      TIMELINE.record('a4', { hz: a4Reference });
    };
    document.getElementById('btn-a4-down').onclick = () => {
      setA4Reference(a4Reference - 1);
      document.getElementById('status').innerText = `A4 = ${a4Reference} Hz`;
      TIMELINE.record('a4', { hz: a4Reference });
    };

    // ============ TIMELINE CONTROLS ============
    document.getElementById('btn-rec').onclick = () => {
      timelineRecording = !timelineRecording;
      const btn = document.getElementById('btn-rec');
      btn.classList.toggle('active', timelineRecording);
      document.getElementById('status').innerText = timelineRecording ? 'REC: ON' : 'REC: OFF';
    };

    document.getElementById('tl-snap').onclick = () => {
      TIMELINE.snapshot();
      document.getElementById('status').innerText = `SNAPSHOT @ BAR ${currentBar}`;
    };

    document.getElementById('tl-clear').onclick = () => {
      TIMELINE.clear();
      document.getElementById('status').innerText = 'TIMELINE CLEARED';
    };

    document.getElementById('tl-copy').onclick = () => {
      const dsl = TIMELINE.toDSL();
      navigator.clipboard.writeText(dsl).then(() => {
        document.getElementById('status').innerText = 'DSL COPIED!';
      });
    };

    // Mini-format parser (tweet format: BPM:120, 1000:x...x...)
    function parseMiniFormat(text) {
      const lines = text.trim().split('\n');
      let isMini = lines.some(l => /^(BPM:|[0-9A-Fa-f]{4}:)/.test(l.trim()));
      if (!isMini) return null;

      let bpm = 120;
      const patterns = { kick: [], snare: [], lead: [], bass: [], noise: [] };
      const addrMap = {
        '1000': 'kick', '1020': 'snare', '1100': 'lead', '1200': 'bass', '1300': 'noise'
      };

      for (const line of lines) {
        const l = line.trim();
        if (!l || l.startsWith('#') || l.startsWith(';')) continue;

        if (l.toUpperCase().startsWith('BPM:')) {
          bpm = parseInt(l.slice(4)) || 120;
          continue;
        }

        const match = l.match(/^([0-9A-Fa-f]{4}):(.+)$/);
        if (match) {
          const voice = addrMap[match[1].toUpperCase()];
          if (voice) {
            const data = match[2].replace(/\s/g, '');
            for (let i = 0; i < 16 && i < data.length; i++) {
              const ch = data[i];
              if (ch === 'x' || ch === 'X') {
                patterns[voice][i] = 1;
              } else if (ch === '.') {
                patterns[voice][i] = 0;
              } else if (/[0-9A-Fa-f]/.test(ch) && i + 1 < data.length && /[0-9A-Fa-f]/.test(data[i + 1])) {
                patterns[voice][Math.floor(i / 2)] = parseInt(data[i] + data[i + 1], 16);
                i++;
              }
            }
          }
        }
      }

      return { bpm, patterns };
    }

    function loadMiniFormat(data) {
      tempo = data.bpm;
      document.getElementById('tempo-slider').value = tempo;
      document.getElementById('tempo-val').textContent = tempo;

      // Load patterns into memory/UI
      ['kick', 'snare', 'lead', 'bass', 'noise'].forEach(voice => {
        const pat = data.patterns[voice];
        for (let i = 0; i < 16; i++) {
          const val = pat[i] || 0;
          if (voice === 'kick' || voice === 'snare' || voice === 'noise') {
            STATE[voice].gates[i] = val > 0;
          } else {
            STATE[voice].gates[i] = val;
          }
        }
      });

      refreshAllGrids();
      document.getElementById('status').innerText = 'MINI FORMAT LOADED @ ' + tempo + ' BPM';
    }

    document.getElementById('tl-load').onclick = () => {
      const text = document.getElementById('timeline-output').value;
      try {
        // Check for mini format first
        const miniData = parseMiniFormat(text);
        if (miniData) {
          loadMiniFormat(miniData);
          return;
        }
        // Fall back to DSL
        TIMELINE.loadDSL(text);
      } catch (err) {
        document.getElementById('status').innerText = 'PARSE ERROR: ' + err.message;
      }
    };

    document.getElementById('tl-scrubber').oninput = (e) => {
      const bar = parseInt(e.target.value);
      TIMELINE.scrubTo(bar);
    };

    document.getElementById('tl-midi').onclick = () => {
      exportTimelineMIDI();
    };

    document.getElementById('tl-wav').onclick = () => {
      exportTimelineWAV();
    };

    document.getElementById('tl-title').oninput = (e) => {
      TIMELINE.title = e.target.value;
    };

    document.getElementById('tl-undo').onclick = () => TIMELINE.undo();
    document.getElementById('tl-redo').onclick = () => TIMELINE.redo();

    // ============ KEYBOARD SHORTCUTS ============
    document.addEventListener('keydown', (e) => {
      // Ignore if typing in input/textarea
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

      switch(e.code) {
        case 'Space':
          e.preventDefault();
          togglePlay();
          break;
        case 'Digit1': switchScene(0); break;
        case 'Digit2': switchScene(1); break;
        case 'Digit3': switchScene(2); break;
        case 'Digit4': switchScene(3); break;
        case 'KeyE':
          toggleEvolve();
          break;
        case 'KeyS':
          if (e.metaKey || e.ctrlKey) {
            e.preventDefault();
            TIMELINE.snapshot();
            document.getElementById('status').innerText = `SNAPSHOT @ BAR ${currentBar}`;
          }
          break;
        case 'KeyZ':
          if (e.metaKey || e.ctrlKey) {
            e.preventDefault();
            if (e.shiftKey) TIMELINE.redo();
            else TIMELINE.undo();
          }
          break;
        case 'ArrowUp':
          if (!e.target.matches('.param-slider')) {
            tempo = Math.min(200, tempo + 5);
            document.getElementById('tempo-display').innerText = tempo;
          }
          break;
        case 'ArrowDown':
          if (!e.target.matches('.param-slider')) {
            tempo = Math.max(60, tempo - 5);
            document.getElementById('tempo-display').innerText = tempo;
          }
          break;
        case 'KeyM':
          mutateAll();
          break;
        case 'KeyT':
          document.getElementById('btn-tools').click();
          break;
      }
    });

    // Tools drawer toggle
    document.getElementById('btn-tools').onclick = () => {
      const drawer = document.getElementById('tools-drawer');
      const btn = document.getElementById('btn-tools');
      const isClosing = drawer.classList.contains('open');
      drawer.classList.toggle('open');
      btn.classList.toggle('active');

      // Collapse panels when closing drawer
      if (isClosing) {
        document.getElementById('evolve-panel').classList.remove('open');
        document.getElementById('timeline-panel').classList.remove('open');
        document.getElementById('btn-timeline').classList.remove('active');
      }
    };

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.onclick = () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.voice-panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`panel-${tab.dataset.voice}`).classList.add('active');
      };
    });

    // Scene switching
    document.querySelectorAll('.scene-btn').forEach(btn => {
      btn.onclick = () => switchScene(parseInt(btn.dataset.scene));
    });
    document.getElementById('btn-copy').onclick = startCopyMode;

    // Advanced feature buttons
    document.getElementById('btn-genre').onclick = () => DrumMind.nextGenre();
    document.getElementById('btn-scale').onclick = cycleScale;

    // ============ PACK BROWSER SYSTEM ============
    window.loadedPacks = [];
    let packBrowserMode = 'or';
    let packBrowserFilter = 'all';

    function openPackBrowser() {
      document.getElementById('pack-overlay').classList.add('open');
      document.getElementById('pack-browser').classList.add('open');
      renderPackGrid();
      renderPackStack();
    }

    function closePackBrowser() {
      document.getElementById('pack-overlay').classList.remove('open');
      document.getElementById('pack-browser').classList.remove('open');
    }

    function renderPackGrid() {
      const grid = document.getElementById('pack-grid');
      grid.innerHTML = '';
      const loadedNames = window.loadedPacks.map(p => p.name);
      Object.keys(PACKS).forEach(key => {
        const pack = PACKS[key];
        const cat = PACK_CATS[key] || 'other';
        if (packBrowserFilter !== 'all' && cat !== packBrowserFilter) return;

        const item = document.createElement('div');
        item.className = `pack-item ${cat}` + (loadedNames.includes(key) ? ' loaded' : '');
        item.innerHTML = `<div class="pack-item-name">${key}</div><div class="pack-item-year">${pack.year}</div>`;
        item.onclick = () => loadPack(key);
        grid.appendChild(item);
      });
    }

    function renderPackStack() {
      const stack = document.getElementById('pack-stack');
      // Remove old chips and mode labels
      stack.querySelectorAll('.pack-chip, .pack-mode-label').forEach(c => c.remove());

      const modeLabels = { replace: '', or: 'OR', and: 'AND', drums: 'DRM', synth: 'SYN' };

      window.loadedPacks.forEach((p, i) => {
        // Show mode label before pack (except first pack)
        if (i > 0 && p.mode && p.mode !== 'replace') {
          const label = document.createElement('span');
          label.className = 'pack-mode-label';
          label.innerText = modeLabels[p.mode] || p.mode.toUpperCase();
          stack.appendChild(label);
        }

        const cat = PACK_CATS[p.name] || 'other';
        const chip = document.createElement('span');
        chip.className = `pack-chip ${cat}`;
        chip.innerHTML = `${p.name} <span class="pack-chip-remove" data-pack="${p.name}">&times;</span>`;
        stack.appendChild(chip);
      });

      // Update mini display in toolbar with mode labels
      const mini = document.getElementById('pack-stack-mini');
      if (mini) {
        if (window.loadedPacks.length === 0) {
          mini.innerText = '';
        } else {
          const parts = window.loadedPacks.map((p, i) => {
            if (i === 0) return p.name;
            const m = modeLabels[p.mode] || '+';
            return m ? `${m} ${p.name}` : p.name;
          });
          mini.innerText = parts.join(' ');
        }
      }
    }

    function loadPack(packName) {
      if (!PACKS[packName]) return;
      const pack = PACKS[packName];
      const mode = packBrowserMode;

      // Define address ranges for filtering
      const drumAddrs = [0x1000, 0x1010, 0x1020, 0x1030, 0x1040, 0x1050, 0x1058, 0x1059, 0x1080, 0x1090, 0x1300, 0x1310, 0x1320, 0x1330, 0x135A];
      const synthAddrs = [0x1100, 0x1110, 0x1120, 0x115A, 0x1200, 0x1210, 0x1220, 0x125A, 0x105E, 0x105F];
      const globalAddrs = [0x1501, 0x1503, 0x1050, 0x1051, 0x1052, 0x1053, 0x1054, 0x1055, 0x1056, 0x1057, 0x1058, 0x1059];

      // Apply pack init pokes based on mode
      const pokes = pack.init();
      pokes.forEach(([addr, val]) => {
        const isDrum = drumAddrs.some(a => addr >= a && addr < a + 16);
        const isSynth = synthAddrs.some(a => addr >= a && addr < a + 16);
        const isGlobal = globalAddrs.includes(addr);

        if (mode === 'drums' && !isDrum && !isGlobal) return;
        if (mode === 'synth' && !isSynth && !isGlobal) return;

        let applied = false;
        if (mode === 'replace') {
          MEM[addr] = val;
          applied = true;
        } else if (mode === 'or') {
          if (val !== 0) { MEM[addr] = val; applied = true; }
        } else if (mode === 'and') {
          if (val !== 0 && MEM[addr] !== 0) { MEM[addr] = val; applied = true; }
        } else {
          MEM[addr] = val;
          applied = true;
        }

        if (applied) {
          if (addr === 0x1503) {
            swing = val;
            document.getElementById('swing-display').innerText = `SW ${val}%`;
          } else if (addr === 0x1501) {
            tempo = val;
            document.getElementById('tempo-display').innerText = val;
          }
        }
      });

      // Load patterns
      if (pack.patterns) {
        const patternName = Object.keys(pack.patterns)[0];
        const pattern = pack.patterns[patternName];

        if (pattern.bpm && mode !== 'and') {
          tempo = pattern.bpm;
          MEM[0x1501] = tempo;
          document.getElementById('tempo-display').innerText = tempo;
        }

        const voiceAddrs = { kick: 0x1000, snare: 0x1020, lead: 0x1100, bass: 0x1200, noise: 0x1300 };
        const drumVoices = ['kick', 'snare', 'noise'];
        const synthVoices = ['lead', 'bass'];

        Object.keys(voiceAddrs).forEach(voice => {
          if (mode === 'drums' && !drumVoices.includes(voice)) return;
          if (mode === 'synth' && !synthVoices.includes(voice)) return;

          if (pattern[voice]) {
            const addr = voiceAddrs[voice];
            const data = parsePackPattern(pattern[voice]);
            data.forEach((val, i) => {
              let newVal = val;
              if (mode === 'or') newVal = val !== 0 ? val : MEM[addr + i];
              else if (mode === 'and') newVal = (val !== 0 && MEM[addr + i] !== 0) ? val : 0;
              MEM[addr + i] = newVal;
            });
          }
        });
      }

      // Update stack with mode tracking
      const loadedNames = window.loadedPacks.map(p => p.name);
      if (mode === 'replace') {
        window.loadedPacks = [{ name: packName, mode: 'replace' }];
      } else {
        if (!loadedNames.includes(packName)) {
          window.loadedPacks.push({ name: packName, mode: mode });
        }
      }

      updateMemDisplay();
      syncGridsFromMem();
      syncSlidersFromMem();
      renderPackGrid();
      renderPackStack();

      // Build status string with mode labels
      const modeLabels = { replace: '', or: 'OR', and: 'AND', drums: 'DRM', synth: 'SYN' };
      const statusParts = window.loadedPacks.map((p, i) => {
        if (i === 0) return p.name;
        const m = modeLabels[p.mode] || '+';
        return m ? `${m} ${p.name}` : p.name;
      });
      document.getElementById('status').innerText = `PACK: ${statusParts.join(' ')}`;
      document.getElementById('genre-display').innerText = window.loadedPacks.length > 1
        ? `${window.loadedPacks.length}PKS` : packName.split('-')[0];
    }

    function removePack(packName) {
      const idx = window.loadedPacks.findIndex(p => p.name === packName);
      if (idx > -1) {
        window.loadedPacks.splice(idx, 1);
        renderPackGrid();
        renderPackStack();
        if (window.loadedPacks.length === 0) {
          document.getElementById('status').innerText = 'READY';
        } else {
          const modeLabels = { replace: '', or: 'OR', and: 'AND', drums: 'DRM', synth: 'SYN' };
          const statusParts = window.loadedPacks.map((p, i) => {
            if (i === 0) return p.name;
            const m = modeLabels[p.mode] || '+';
            return m ? `${m} ${p.name}` : p.name;
          });
          document.getElementById('status').innerText = `PACK: ${statusParts.join(' ')}`;
        }
      }
    }

    // Pack browser event wiring
    document.getElementById('btn-packs').onclick = openPackBrowser;
    document.getElementById('pack-browser-close').onclick = closePackBrowser;
    document.getElementById('pack-overlay').onclick = closePackBrowser;

    // Facet filters
    document.querySelectorAll('.pack-facet').forEach(btn => {
      btn.onclick = () => {
        document.querySelectorAll('.pack-facet').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        packBrowserFilter = btn.dataset.cat;
        renderPackGrid();
      };
    });

    // Mode buttons
    document.querySelectorAll('.pack-mode-btn').forEach(btn => {
      btn.onclick = () => {
        document.querySelectorAll('.pack-mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        packBrowserMode = btn.dataset.mode;
      };
    });

    // Stack chip removal (delegated)
    document.getElementById('pack-stack').onclick = (e) => {
      if (e.target.classList.contains('pack-chip-remove')) {
        removePack(e.target.dataset.pack);
      }
    };

    document.getElementById('btn-evolve').onclick = toggleEvolve;
    document.getElementById('btn-lfo').onclick = toggleLFO;

    // Evolve panel wiring
    document.querySelectorAll('.evo-row[data-v]').forEach(row => {
      const v = row.dataset.v;
      row.querySelector('.evo-on').onchange = e => EVOLVE.voices[v].on = e.target.checked;
      row.querySelector('.evo-amt').oninput = e => EVOLVE.voices[v].amt = parseInt(e.target.value);
      row.querySelector('.evo-shift').onchange = e => EVOLVE.voices[v].shift = e.target.checked;
      row.querySelector('.evo-addrm').onchange = e => EVOLVE.voices[v].addRm = e.target.checked;
      row.querySelector('.evo-oct').onchange = e => EVOLVE.voices[v].oct = e.target.checked;
      row.querySelector('.evo-rev').onchange = e => EVOLVE.voices[v].rev = e.target.checked;
      row.querySelector('.evo-prob').onchange = e => EVOLVE.voices[v].prob = e.target.checked;
      row.querySelector('.evo-ratch').onchange = e => EVOLVE.voices[v].ratch = e.target.checked;
      row.querySelector('.evo-swap').onchange = e => EVOLVE.voices[v].swap = e.target.checked;
    });
    document.querySelector('.evo-interval').onchange = e => EVOLVE.interval = parseInt(e.target.value);
    document.querySelectorAll('input[name="humanize"]').forEach(r => {
      r.onchange = e => EVOLVE.humanize = parseInt(e.target.value);
    });
    document.querySelector('.evo-density').oninput = e => EVOLVE.density = parseInt(e.target.value);
    document.querySelector('.evo-chaos').oninput = e => EVOLVE.chaos = parseInt(e.target.value);
    document.querySelector('.evo-lock').onchange = e => EVOLVE.lockRoot = e.target.checked;
    document.querySelector('.evo-chain').onchange = e => EVOLVE.chainScenes = e.target.checked;

    // Algorithm buttons
    document.getElementById('btn-rotate-l').onclick = () => rotateAllPatterns(-1);
    document.getElementById('btn-rotate-r').onclick = () => rotateAllPatterns(1);
    document.getElementById('btn-life').onclick = applyLifeToAll;
    document.getElementById('btn-invert').onclick = invertAllPatterns;

    // Timeline toggle
    document.getElementById('btn-timeline').onclick = () => {
      const panel = document.getElementById('timeline-panel');
      const btn = document.getElementById('btn-timeline');
      panel.classList.toggle('open');
      btn.classList.toggle('active');
    };

    // Toolchain toggle
    document.getElementById('btn-toolchain').onclick = () => {
      const panel = document.getElementById('toolchain-panel');
      const btn = document.getElementById('btn-toolchain');
      const isOpen = panel.style.display !== 'none';
      panel.style.display = isOpen ? 'none' : 'block';
      btn.classList.toggle('active');
    };

    // Slider value displays
    document.querySelectorAll('.param-slider').forEach(slider => {
      slider.oninput = () => {
        const id = slider.id.replace('param-', 'val-');
        const display = document.getElementById(id);
        if (display) {
          if (id.includes('-note')) {
            display.innerText = midiToName(parseInt(slider.value));
          } else if (id.includes('-prob')) {
            // 0 means 100% (default)
            display.innerText = parseInt(slider.value) === 0 ? '100' : slider.value;
          } else {
            display.innerText = slider.value;
          }
        }
      };
    });

    // ADSR sliders → MEM
    document.querySelectorAll('.adsr-slider').forEach(slider => {
      const voice = slider.dataset.voice;
      const param = parseInt(slider.dataset.param); // 0=A, 1=D, 2=S, 3=R
      const baseAddr = VOICES[voice].adsr;

      // Initialize MEM from slider default
      MEM[baseAddr + param] = parseInt(slider.value);

      slider.oninput = () => {
        MEM[baseAddr + param] = parseInt(slider.value);
        scheduleAutoSave();
      };
    });

    // Detune sliders → voiceDetune array
    document.querySelectorAll('.detune-slider').forEach(slider => {
      const voiceIdx = parseInt(slider.dataset.voice);
      const voiceName = ['kick', 'snare', 'lead', 'bass', 'noise'][voiceIdx];

      slider.oninput = () => {
        const cents = parseInt(slider.value);
        setVoiceDetune(voiceIdx, cents);
        const valEl = document.getElementById(`val-detune-${voiceName}`);
        if (valEl) valEl.innerText = `${cents >= 0 ? '+' : ''}${cents}¢`;
      };
    });

    // Boot
    initGrids();
    initMem();
    updateMemDisplay();
    startHeatDecay();

    // LCD Boot Animation
    let bootFrame = 0;
    let bootAnimId = null;

    function drawBootLCD() {
      const t = bootFrame / 60;  // Time in seconds

      // Background - classic GB green
      ctx.fillStyle = C[0];
      ctx.fillRect(0, 0, 160, 144);

      // Scanlines effect
      ctx.fillStyle = 'rgba(0,0,0,0.03)';
      for (let y = 0; y < 144; y += 2) {
        ctx.fillRect(0, y, 160, 1);
      }

      // Phase 1: Matrix-style falling chars (0-1s)
      if (t < 1.2) {
        ctx.font = '8px monospace';
        ctx.fillStyle = C[2];
        for (let x = 0; x < 16; x++) {
          const speed = 3 + (x % 5);
          const y = ((bootFrame * speed + x * 20) % 180) - 36;
          const char = String.fromCharCode(0x30 + ((bootFrame + x * 7) % 16));
          ctx.fillText(char, x * 10 + 2, y);
          ctx.fillStyle = (bootFrame + x) % 3 === 0 ? C[3] : C[2];
        }
      }

      // Phase 2: Logo appears (0.5s+)
      if (t > 0.5) {
        const logoAlpha = Math.min(1, (t - 0.5) * 2);
        ctx.fillStyle = C[3];
        ctx.font = 'bold 16px monospace';
        const logoY = 50 + Math.sin(t * 3) * 3;
        ctx.globalAlpha = logoAlpha;
        ctx.fillText('$1010', 48, logoY);
        ctx.font = '10px monospace';
        ctx.fillText('SEQUENCER', 40, logoY + 16);
        ctx.globalAlpha = 1;
      }

      // Phase 3: Waveform preview (1s+)
      if (t > 1) {
        ctx.strokeStyle = C[2];
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let x = 0; x < 160; x++) {
          const wave = Math.sin((x + bootFrame * 2) * 0.1) * 15 +
                       Math.sin((x + bootFrame * 3) * 0.05) * 10;
          const y = 100 + wave;
          if (x === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Bass wave
        ctx.strokeStyle = C[3];
        ctx.beginPath();
        for (let x = 0; x < 160; x++) {
          const wave = Math.sin((x - bootFrame) * 0.05) * 20;
          const y = 120 + wave;
          if (x === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }

      // Memory address crawl at bottom
      ctx.fillStyle = C[2];
      ctx.font = '7px monospace';
      const addr = (0x1000 + (bootFrame * 2) % 0x400).toString(16).toUpperCase();
      ctx.fillText(`MEM $${addr.padStart(4, '0')}`, 4, 140);

      // Grid dots appearing
      if (t > 0.8) {
        const dotsVisible = Math.floor((t - 0.8) * 40);
        for (let i = 0; i < Math.min(dotsVisible, 32); i++) {
          const x = (i % 16) * 10 + 5;
          const y = Math.floor(i / 16) * 20 + 10;
          ctx.fillStyle = i % 3 === 0 ? C[3] : C[2];
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      bootFrame++;
      if (bootFrame < 150) {  // ~2.5 seconds at 60fps
        bootAnimId = requestAnimationFrame(drawBootLCD);
      }
    }

    // Start LCD boot animation
    drawBootLCD();

    // Boot screen fadeout after animation completes
    setTimeout(() => {
      const bootScreen = document.getElementById('boot-screen');
      if (bootScreen) {
        bootScreen.classList.add('fade-out');
        setTimeout(() => bootScreen.remove(), 500);
      }
      // Stop boot animation and draw normal LCD
      if (bootAnimId) cancelAnimationFrame(bootAnimId);
      drawLCD();
    }, 2200);
  </script>
</body>

</html>
